<!DOCTYPE html>
<html lang="ro">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quiz Cursuri CC</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #f4f4f9;
    }

    .container {
      width: 90%;
      max-width: 500px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      padding: 30px;
      text-align: center;
    }

    h1 {
      font-size: 28px;
      margin-bottom: 30px;
    }

    .quiz-section {
      display: none;
    }

    .quiz-section.active {
      display: block;
    }

    .question {
      font-size: 22px;
      margin-bottom: 20px;
    }

    .answer {
      display: flex;
      align-items: center;
      margin: 12px 0;
    }

    .answer input {
      margin-right: 15px;
    }

    .answer span {
      font-size: 22px;
      cursor: pointer;
    }

    .feedback {
      margin-top: 20px;
      font-weight: bold;
      font-size: 18px;
    }

    .next-btn {
      margin-top: 20px;
      padding: 12px 25px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background-color: #4caf50;
      color: white;
      border-radius: 4px;
    }

    .select-course {
      margin-bottom: 20px;
    }

    select {
      padding: 10px;
      font-size: 18px;
      width: 100%;
      margin-bottom: 10px;
    }

    button {
      padding: 12px 30px;
      font-size: 18px;
      cursor: pointer;
    }

    .question-info {
      font-size: 18px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="select-course" id="courseSelection">
      <label for="courseSelect">Alegeți un curs:</label>
      <select id="courseSelect">
        <option value="CC-04">Cloud Computing 04</option>
        <option value="CC-05">Cloud Computing 05</option>
        <option value="CC-07">Cloud Computing 07</option>
        <option value="CC-08">Cloud Computing 08</option>
        <option value="CC-09">Cloud Computing 09</option>
        <option value="CC-10">Cloud Computing 10</option>
      </select>
      <div>
        <input type="checkbox" id="randomToggle" checked />
        <label for="randomToggle">Întrebări în ordine aleatorie</label>
      </div>
      <div>
        <input type="checkbox" id="answerRandomToggle" checked />
        <label for="answerRandomToggle">Răspunsuri în ordine aleatorie</label>
      </div>
      <button onclick="loadQuiz()">Încarcă întrebările</button>
    </div>
    <div id="quiz-container"></div>
  </div>

  <script>

    const CC04 = [
      {
        "question": "Care este scopul principal al Kubernetes?",
        "answers": [
          {
            "text": "Gestionarea automată a aplicațiilor care rulează în containere",
            "correct": true
          },
          {
            "text": "Crearea de baze de date pentru aplicații",
            "correct": false
          },
          {
            "text": "Scrierea codului pentru aplicații web",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce permite Kubernetes în gestionarea containerelor?",
        "answers": [
          {
            "text": "Pornirea, conectarea, scalarea și distribuirea containerelor pe mai multe noduri",
            "correct": true
          },
          {
            "text": "Scrierea codului pentru containere",
            "correct": false
          },
          {
            "text": "Limitarea numărului de utilizatori pentru fiecare container",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem porni un container în Kubernetes?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl create deployment'",
            "correct": true
          },
          {
            "text": "Prin scrierea unui script Bash",
            "correct": false
          },
          {
            "text": "Prin editarea manuală a fișierelor de configurare ale serverului",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este dezavantajul pornirii manuale a unui Deployment în Kubernetes?",
        "answers": [
          {
            "text": "Necesită intervenție manuală din partea unui operator",
            "correct": true
          },
          {
            "text": "Nu permite scalarea automată a containerelor",
            "correct": false
          },
          {
            "text": "Nu permite conectarea containerelor între ele",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este avantajul utilizării fișierelor manifest pentru Deployment-uri în Kubernetes?",
        "answers": [
          {
            "text": "Fișierele sunt repoziționabile și pot fi gestionate cu Git",
            "correct": true
          },
          {
            "text": "Fișierele manifest permit rularea mai rapidă a containerelor",
            "correct": false
          },
          {
            "text": "Fișierele manifest elimină complet necesitatea comenzilor Kubernetes",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce tip de fișier este folosit pentru a defini un Deployment în Kubernetes?",
        "answers": [
          {
            "text": "Fișier YAML",
            "correct": true
          },
          {
            "text": "Fișier JSON",
            "correct": false
          },
          {
            "text": "Fișier XML",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce secțiune dintr-un fișier manifest definește numărul de replici pentru un Deployment?",
        "answers": [
          {
            "text": "spec.replicas",
            "correct": true
          },
          {
            "text": "metadata.labels",
            "correct": false
          },
          {
            "text": "apiVersion",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce informații conține secțiunea 'metadata' într-un fișier manifest pentru un deployment?",
        "answers": [
          {
            "text": "Numele deploymentului și etichetele (label-urile) asociate",
            "correct": true
          },
          {
            "text": "Configurările de rețea ale deploymentului",
            "correct": false
          },
          {
            "text": "Lista containerelor din deployment",
            "correct": false
          }
        ]
      },
      {
        "question": "La ce sunt folosite etichetele (label-urile) într-un deployment Kubernetes?",
        "answers": [
          {
            "text": "Pentru a selecta obiectele asociate unei aplicații",
            "correct": true
          },
          {
            "text": "Pentru a defini numărul de replici ale deploymentului",
            "correct": false
          },
          {
            "text": "Pentru a seta permisiuni pe poduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce comandă creează un obiect nou dintr-un fișier manifest în Kubernetes?",
        "answers": [
          {
            "text": "kubectl create -f",
            "correct": true
          },
          {
            "text": "kubectl apply -f",
            "correct": false
          },
          {
            "text": "kubectl start -f",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este diferența dintre 'kubectl create -f' și 'kubectl apply -f'?",
        "answers": [
          {
            "text": "'apply' aplică și modificări asupra obiectelor existente, pe când 'create' doar creează obiecte noi",
            "correct": true
          },
          {
            "text": "'create' aplică modificări asupra obiectelor existente, pe când 'apply' doar creează obiecte noi",
            "correct": false
          },
          {
            "text": "Nu există nicio diferență între cele două comenzi",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem afla IP-ul unui pod în Kubernetes?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl describe pods -l app=nextcloud | grep IP'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl get pods --show-ip'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl show-ip pod nextcloud'",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem filtra podurile după eticheta 'app=nextcloud'?",
        "answers": [
          {
            "text": "Folosind opțiunea '-l app=nextcloud' în comenzi",
            "correct": true
          },
          {
            "text": "Folosind opțiunea '--filter app=nextcloud' în comenzi",
            "correct": false
          },
          {
            "text": "Editând manual fișierul manifest",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce se întâmplă cu IP-ul unui pod Kubernetes dacă acesta este șters și regenerat?",
        "answers": [
          {
            "text": "IP-ul se modifică",
            "correct": true
          },
          {
            "text": "IP-ul rămâne același",
            "correct": false
          },
          {
            "text": "Podul nu mai primește un IP nou",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce comandă putem folosi pentru a șterge un pod cu eticheta 'app=nextcloud'?",
        "answers": [
          {
            "text": "kubectl delete pods -l app=nextcloud",
            "correct": true
          },
          {
            "text": "kubectl remove pod nextcloud",
            "correct": false
          },
          {
            "text": "kubectl erase pod nextcloud",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem verifica detaliile unui pod folosind comanda 'kubectl describe'?",
        "answers": [
          {
            "text": "Folosind 'kubectl describe pods -l app=nextcloud'",
            "correct": true
          },
          {
            "text": "Folosind 'kubectl show pods nextcloud'",
            "correct": false
          },
          {
            "text": "Folosind 'kubectl info pod nextcloud'",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este scopul principal al comenzii 'kubectl apply -f'?",
        "answers": [
          {
            "text": "Să creeze obiecte și să aplice modificări asupra obiectelor existente",
            "correct": true
          },
          {
            "text": "Să creeze doar obiecte noi, fără a modifica obiectele existente",
            "correct": false
          },
          {
            "text": "Să șteargă și să recreeze obiectele dintr-un fișier manifest",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum se pot conecta podurile între ele într-un cluster Kubernetes fără politici de securitate?",
        "answers": [
          {
            "text": "Folosind IP-ul fiecărui pod",
            "correct": true
          },
          {
            "text": "Folosind numele podului",
            "correct": false
          },
          {
            "text": "Folosind un fișier de configurare static",
            "correct": false
          }
        ]
      },
      {
        "question": "De ce identificarea unui pod doar prin IP poate fi problematică?",
        "answers": [
          {
            "text": "Pentru că IP-ul unui pod se schimbă la fiecare restart sau redeploy",
            "correct": true
          },
          {
            "text": "Pentru că Kubernetes nu alocă IP-uri unice podurilor",
            "correct": false
          },
          {
            "text": "Pentru că podurile nu pot comunica între ele prin IP-uri",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce se întâmplă cu IP-ul unui pod dacă acesta este oprit și repornit?",
        "answers": [
          {
            "text": "IP-ul se schimbă",
            "correct": true
          },
          {
            "text": "IP-ul rămâne același",
            "correct": false
          },
          {
            "text": "Podul nu mai primește un IP",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce rol au obiectele de tip Service în Kubernetes?",
        "answers": [
          {
            "text": "Expun un deployment sau un set de poduri către cluster sau exterior",
            "correct": true
          },
          {
            "text": "Sunt folosite pentru a stoca date în Kubernetes",
            "correct": false
          },
          {
            "text": "Se ocupă cu gestionarea resurselor CPU și memorie pentru poduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum se creează un serviciu pentru a expune deploymentul nextcloud?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl expose deployment nextcloud --port 80'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl create service nextcloud'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl apply -f nextcloud-service.yaml'",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce resursă este asociată unui serviciu Kubernetes după ce este creat?",
        "answers": [
          {
            "text": "Un IP și un port",
            "correct": true
          },
          {
            "text": "Un volum de stocare",
            "correct": false
          },
          {
            "text": "Un cont de utilizator",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem verifica serviciile existente într-un cluster Kubernetes?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl get services'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl describe pods'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl list deployments'",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce tip de IP este asociat serviciilor Kubernetes de tip ClusterIP?",
        "answers": [
          {
            "text": "Un IP static disponibil doar în cadrul clusterului",
            "correct": true
          },
          {
            "text": "Un IP public accesibil din internet",
            "correct": false
          },
          {
            "text": "Un IP dinamic care se schimbă la fiecare restart",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum poate un pod să se conecteze la un serviciu Kubernetes?",
        "answers": [
          {
            "text": "Prin Cluster IP sau prin numele serviciului",
            "correct": true
          },
          {
            "text": "Doar prin Cluster IP",
            "correct": false
          },
          {
            "text": "Doar printr-un volum montat",
            "correct": false
          }
        ]
      },
      {
        "question": "De ce este util să folosim numele unui serviciu în loc de IP?",
        "answers": [
          {
            "text": "Pentru a permite configurări statice și a evita schimbarea IP-urilor",
            "correct": true
          },
          {
            "text": "Pentru a crește securitatea serviciului",
            "correct": false
          },
          {
            "text": "Pentru a consuma mai puține resurse în Kubernetes",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce se întâmplă cu Cluster IP-ul unui serviciu după ștergerea și recrearea podurilor asociate?",
        "answers": [
          {
            "text": "Cluster IP-ul rămâne același",
            "correct": true
          },
          {
            "text": "Cluster IP-ul se schimbă",
            "correct": false
          },
          {
            "text": "Serviciul este șters automat",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem testa conectivitatea către un serviciu Kubernetes dintr-un alt pod?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl exec -it <pod> -- curl <Cluster IP>'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl connect service <service-name>'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl ping <service-name>'",
            "correct": false
          }
        ]
      },
      {
        "question": "Cine poate accesa un serviciu Kubernetes de tip ClusterIP?",
        "answers": [
          {
            "text": "Doar podurile din cluster",
            "correct": true
          },
          {
            "text": "Oricine din internet",
            "correct": false
          },
          {
            "text": "Doar nodurile fizice ale clusterului",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce tip de serviciu Kubernetes permite conexiuni din exteriorul clusterului?",
        "answers": [
          {
            "text": "NodePort",
            "correct": true
          },
          {
            "text": "ClusterIP",
            "correct": false
          },
          {
            "text": "PodPort",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem obține adresa IP a unui nod în Kubernetes?",
        "answers": [
          {
            "text": "Folosind comanda 'kubectl get nodes -o wide'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl describe services'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl get pods -o json'",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este dezavantajul principal al folosirii NodePort pentru expunerea serviciilor?",
        "answers": [
          {
            "text": "Trebuie să cunoaștem și să distribuim manual adresa IP a nodului",
            "correct": true
          },
          {
            "text": "Nu suportă conexiuni externe",
            "correct": false
          },
          {
            "text": "Poate fi utilizat doar în infrastructuri cloud",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce alternativă oferă infrastructurile cloud pentru expunerea serviciilor Kubernetes?",
        "answers": [
          {
            "text": "Utilizarea unui load balancer",
            "correct": true
          },
          {
            "text": "Configurarea manuală a adreselor IP publice",
            "correct": false
          },
          {
            "text": "Alocarea unui port dinamic pentru fiecare serviciu",
            "correct": false
          }
        ]
      },
      {
        "question": "În ce situație este util să folosim NodePort?",
        "answers": [
          {
            "text": "Când avem infrastructuri private sau nu avem acces la adrese IP publice",
            "correct": true
          },
          {
            "text": "Când vrem să facem serviciul accesibil global",
            "correct": false
          },
          {
            "text": "Când dorim să scalăm serviciul automat",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce tip de serviciu Kubernetes poate aloca un IP extern pentru a redirecționa conexiuni către un cluster?",
        "answers": [
          {
            "text": "LoadBalancer",
            "correct": true
          },
          {
            "text": "ClusterIP",
            "correct": false
          },
          {
            "text": "NodePort",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce comandă putem folosi pentru a obține lista serviciilor din Kubernetes?",
        "answers": [
          {
            "text": "kubectl get services",
            "correct": true
          },
          {
            "text": "kubectl get pods",
            "correct": false
          },
          {
            "text": "kubectl get ingress",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este diferența principală dintre un serviciu ClusterIP și un serviciu LoadBalancer?",
        "answers": [
          {
            "text": "LoadBalancer alocă un ExternalIP vizibil din afara clusterului",
            "correct": true
          },
          {
            "text": "ClusterIP este mai rapid decât LoadBalancer",
            "correct": false
          },
          {
            "text": "LoadBalancer este utilizat doar pentru baze de date",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum verificăm conectivitatea la un serviciu Kubernetes LoadBalancer?",
        "answers": [
          {
            "text": "Folosind comanda 'ping <service-ip>'",
            "correct": true
          },
          {
            "text": "Folosind comanda 'kubectl describe services'",
            "correct": false
          },
          {
            "text": "Folosind comanda 'kubectl exec -it <pod> -- curl localhost'",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce resursă Kubernetes poate gestiona automat alocarea unei adrese IP publice pentru mai multe servicii?",
        "answers": [
          {
            "text": "Ingress Controller",
            "correct": true
          },
          {
            "text": "NodePort",
            "correct": false
          },
          {
            "text": "PersistentVolume",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum funcționează un Ingress Controller?",
        "answers": [
          {
            "text": "Preia conexiuni externe și le redirecționează către serviciile din cluster",
            "correct": true
          },
          {
            "text": "Atribuie automat adrese IP fiecărui pod",
            "correct": false
          },
          {
            "text": "Monitorizează starea nodurilor din Kubernetes",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce serviciu de rețea este utilizat de Kubernetes pentru a gestiona conexiunile de tip Ingress?",
        "answers": [
          {
            "text": "nginx",
            "correct": true
          },
          {
            "text": "Apache",
            "correct": false
          },
          {
            "text": "Traefik",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce rol are obiectul Ingress în Kubernetes?",
        "answers": [
          {
            "text": "Definirea unei rute de acces la un serviciu",
            "correct": true
          },
          {
            "text": "Crearea automată a unor poduri noi",
            "correct": false
          },
          {
            "text": "Asigurarea redundanței pentru baze de date",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce comandă aplică un fișier de configurare Ingress în Kubernetes?",
        "answers": [
          {
            "text": "kubectl apply -f <file>.yaml",
            "correct": true
          },
          {
            "text": "kubectl create ingress <file>.yaml",
            "correct": false
          },
          {
            "text": "kubectl expose ingress <file>.yaml",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce componentă poate gestiona certificările SSL automat în Kubernetes?",
        "answers": [
          {
            "text": "cert-manager",
            "correct": true
          },
          {
            "text": "LoadBalancer",
            "correct": false
          },
          {
            "text": "ServiceMesh",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem verifica obiectele Ingress dintr-un cluster Kubernetes?",
        "answers": [
          {
            "text": "kubectl get ingress",
            "correct": true
          },
          {
            "text": "kubectl get loadbalancers",
            "correct": false
          },
          {
            "text": "kubectl get networking",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce serviciu Kubernetes permite utilizarea unei singure adrese IP publice pentru multiple servicii HTTP?",
        "answers": [
          {
            "text": "Ingress Controller",
            "correct": true
          },
          {
            "text": "LoadBalancer",
            "correct": false
          },
          {
            "text": "ClusterIP",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem face scalarea manuală a unui deployment în Kubernetes?",
        "answers": [
          {
            "text": "Folosind comanda kubectl scale deployment <nume> --replicas <număr replici>",
            "correct": true
          },
          {
            "text": "Folosind comanda kubectl scale cluster <nume> --replicas <număr replici>",
            "correct": false
          },
          {
            "text": "Folosind fișierele YAML pentru a modifica manual numărul de replici",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce cuvânt cheie se folosește într-un manifest pentru a seta numărul de replici ale unui deployment?",
        "answers": [
          {
            "text": "replicas",
            "correct": true
          },
          {
            "text": "instances",
            "correct": false
          },
          {
            "text": "count",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum poate scalarea statică a serviciilor să ajute un deployment?",
        "answers": [
          {
            "text": "Permite mărirea capacității unui serviciu și garantează disponibilitatea aplicației",
            "correct": true
          },
          {
            "text": "Permite alocarea automată de resurse doar atunci când este necesar",
            "correct": false
          },
          {
            "text": "Permite instalarea automată a unei noi aplicații atunci când cererea crește",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce permite scalarea automată a deploymenturilor într-un sistem cloud?",
        "answers": [
          {
            "text": "Reducerea costurilor prin ajustarea numărului de resurse alocate în funcție de cerințele aplicației",
            "correct": true
          },
          {
            "text": "Stabilirea unui număr fix de poduri pentru a îmbunătăți performanța",
            "correct": false
          },
          {
            "text": "Creșterea costurilor prin alocarea constantă a unui număr mare de poduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce tip de resurse poate solicita un pod într-un deployment?",
        "answers": [
          {
            "text": "Resurse CPU și memorie",
            "correct": true
          },
          {
            "text": "Resurse GPU și stocare pe disc",
            "correct": false
          },
          {
            "text": "Resurse pentru backup și rețea",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum impune kubelet limitele de resurse pentru un pod?",
        "answers": [
          {
            "text": "Folosind cgroups",
            "correct": true
          },
          {
            "text": "Folosind Kubernetes API",
            "correct": false
          },
          {
            "text": "Folosind docker-compose",
            "correct": false
          }
        ]
      },
      {
        "question": "Care comandă Kubernetes poate fi folosită pentru a vizualiza resursele utilizate de poduri?",
        "answers": [
          {
            "text": "kubectl top pods",
            "correct": true
          },
          {
            "text": "kubectl describe pods",
            "correct": false
          },
          {
            "text": "kubectl get resources",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce obiect Kubernetes este folosit pentru a scala automat numărul de poduri într-un deployment?",
        "answers": [
          {
            "text": "HorizontalPodAutoscaler (HPA)",
            "correct": true
          },
          {
            "text": "PodAutoscaler",
            "correct": false
          },
          {
            "text": "PodController",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este scopul unui obiect HorizontalPodAutoscaler?",
        "answers": [
          {
            "text": "Monitorizează resursele și ajustează automat numărul de poduri într-un deployment",
            "correct": true
          },
          {
            "text": "Crește numărul de replici pentru a preveni erorile de conexiune",
            "correct": false
          },
          {
            "text": "Se asigură că toate podurile sunt distribuite uniform pe noduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum se determină scalarea numărului de poduri folosind HPA?",
        "answers": [
          {
            "text": "Pe baza mediei utilizării CPU-ului pe toate podurile din deployment",
            "correct": true
          },
          {
            "text": "Pe baza mediei utilizării memoriei pe toate podurile din deployment",
            "correct": false
          },
          {
            "text": "Pe baza numărului de erori înregistrate de poduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum se calculează numărul de replici în HPA?",
        "answers": [
          {
            "text": "Folosing formula: ceil(currentReplicas * (currentCPUValue/desiredCPUValue))",
            "correct": true
          },
          {
            "text": "Folosind formula: ceil(currentReplicas * (desiredCPUValue/currentCPUValue))",
            "correct": false
          },
          {
            "text": "Folosind formula: currentReplicas * 2",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce obiect permite setarea valorii minime și maxime de replici într-un HPA?",
        "answers": [
          {
            "text": "minReplicas și maxReplicas",
            "correct": true
          },
          {
            "text": "replicaMin și replicaMax",
            "correct": false
          },
          {
            "text": "minPods și maxPods",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce unitate de măsură este utilizată pentru a monitoriza CPU-ul în HPA?",
        "answers": [
          {
            "text": "Utilizarea CPU-ului (CPU Utilization)",
            "correct": true
          },
          {
            "text": "Utilizarea memoriei",
            "correct": false
          },
          {
            "text": "Numărul de conexiuni rețea",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce resursă este configurată în secțiunea 'resources' a unui deployment pentru a limita utilizarea unui CPU?",
        "answers": [
          {
            "text": "cpu",
            "correct": true
          },
          {
            "text": "memory",
            "correct": false
          },
          {
            "text": "disk",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce comandă este utilizată pentru a crea un cluster Kubernetes local utilizând Kind?",
        "answers": [
          { "text": "kind create cluster", "correct": true },
          { "text": "kubectl create cluster", "correct": false },
          { "text": "docker create cluster", "correct": false }
        ]
      },
      {
        "question": "Ce rol are o liveness probe într-un container Kubernetes?",
        "answers": [
          { "text": "Verifică dacă aplicația rulează și o restartează dacă eșuează", "correct": true },
          { "text": "Verifică dacă aplicația este pregătită să primească trafic", "correct": false },
          { "text": "Scalează automat numărul de poduri în funcție de încărcare", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă o liveness probe eșuează de mai multe ori consecutiv?",
        "answers": [
          { "text": "Containerul este restartat automat", "correct": true },
          { "text": "Containerul este șters definitiv", "correct": false },
          { "text": "Nu se întâmplă nimic", "correct": false }
        ]
      },
      {
        "question": "Care dintre următoarele opțiuni este o metodă validă pentru readiness probe?",
        "answers": [
          { "text": "httpGet", "correct": true },
          { "text": "pingProbe", "correct": false },
          { "text": "tcpPing", "correct": false }
        ]
      },
      {
        "question": "Ce parametru din readiness probe definește numărul de verificări reușite înainte ca un container să fie considerat gata?",
        "answers": [
          { "text": "successThreshold", "correct": true },
          { "text": "failureThreshold", "correct": false },
          { "text": "periodSeconds", "correct": false }
        ]
      },
      {
        "question": "Ce resursă Kubernetes gestionează numărul de replici ale unui pod?",
        "answers": [
          { "text": "ReplicaSet", "correct": true },
          { "text": "Pod", "correct": false },
          { "text": "Service", "correct": false }
        ]
      },
      {
        "question": "Cum expunem o aplicație rulată într-un pod Kubernetes pentru acces extern?",
        "answers": [
          { "text": "Prin crearea unui Service", "correct": true },
          { "text": "Prin modificarea pod-ului", "correct": false },
          { "text": "Prin utilizarea unei ConfigMap", "correct": false }
        ]
      },
      {
        "question": "Ce tip de Service folosește un port accesibil în afara clusterului?",
        "answers": [
          { "text": "NodePort", "correct": true },
          { "text": "ClusterIP", "correct": false },
          { "text": "LoadBalancer", "correct": false }
        ]
      },
      {
        "question": "Ce comandă listă toate podurile din Kubernetes?",
        "answers": [
          { "text": "kubectl get pods", "correct": true },
          { "text": "kubectl list pods", "correct": false },
          { "text": "kubectl describe pods", "correct": false }
        ]
      },
      {
        "question": "Cum putem încărca o imagine Docker într-un cluster Kind?",
        "answers": [
          { "text": "kind load docker-image <image-name>", "correct": true },
          { "text": "kubectl load docker-image <image-name>", "correct": false },
          { "text": "docker push <image-name>", "correct": false }
        ]
      },
      {
        "question": "Ce obiect Kubernetes acționează ca un API gateway?",
        "answers": [
          { "text": "Ingress", "correct": true },
          { "text": "Service", "correct": false },
          { "text": "Deployment", "correct": false }
        ]
      },
      {
        "question": "Ce tip de Service permite doar acces intern în cluster?",
        "answers": [
          { "text": "ClusterIP", "correct": true },
          { "text": "NodePort", "correct": false },
          { "text": "LoadBalancer", "correct": false }
        ]
      },
      {
        "question": "Ce comandă permite aplicarea unui fișier de configurare Kubernetes?",
        "answers": [
          { "text": "kubectl apply -f <file>", "correct": true },
          { "text": "kubectl create -f <file>", "correct": false },
          { "text": "kubectl add -f <file>", "correct": false }
        ]
      },
      {
        "question": "Ce metodă este utilizată pentru a defini resursele CPU ale unui container?",
        "answers": [
          { "text": "requests și limits", "correct": true },
          { "text": "minCPU și maxCPU", "correct": false },
          { "text": "cpuUsage", "correct": false }
        ]
      },
      {
        "question": "Cum se scalează manual un deployment Kubernetes?",
        "answers": [
          { "text": "kubectl scale deployment <deployment-name> --replicas=<num>", "correct": true },
          { "text": "kubectl autoscale deployment <deployment-name>", "correct": false },
          { "text": "kubectl update deployment <deployment-name> --scale=<num>", "correct": false }
        ]
      },
      {
        "question": "Ce obiect Kubernetes este utilizat pentru a scala automat un deployment?",
        "answers": [
          { "text": "HorizontalPodAutoscaler", "correct": true },
          { "text": "ReplicaSet", "correct": false },
          { "text": "StatefulSet", "correct": false }
        ]
      },
      {
        "question": "Ce parametru din autoscaler specifică numărul minim de replici?",
        "answers": [
          { "text": "minReplicas", "correct": true },
          { "text": "maxReplicas", "correct": false },
          { "text": "targetReplicas", "correct": false }
        ]
      },
      {
        "question": "Care este scopul unui Deployment în Kubernetes?",
        "answers": [
          { "text": "Gestionarea și scalarea automată a podurilor", "correct": true },
          { "text": "Definirea regulilor de rețea pentru poduri", "correct": false },
          { "text": "Persistența datelor între reporniri", "correct": false }
        ]
      },
      {
        "question": "Cum putem verifica evenimentele generate de un pod?",
        "answers": [
          { "text": "kubectl get events --for pod/<pod-name>", "correct": true },
          { "text": "kubectl describe pod <pod-name>", "correct": false },
          { "text": "kubectl log pod <pod-name>", "correct": false }
        ]
      },
      {
        "question": "Ce componentă Kubernetes monitorizează și gestionează starea clusterului?",
        "answers": [
          { "text": "kube-controller-manager", "correct": true },
          { "text": "kubectl", "correct": false },
          { "text": "kube-proxy", "correct": false }
        ]
      },
      {
        "question": "Ce comanda afișează toate resursele dintr-un namespace Kubernetes?",
        "answers": [
          { "text": "kubectl get all", "correct": true },
          { "text": "kubectl get pods --all-namespaces", "correct": false },
          { "text": "kubectl list resources", "correct": false }
        ]
      },
      {
        "question": "Ce tip de volum Kubernetes permite stocarea persistentă a datelor?",
        "answers": [
          { "text": "PersistentVolume", "correct": true },
          { "text": "ConfigMap", "correct": false },
          { "text": "Secret", "correct": false }
        ]
      },
      {
        "question": "Care dintre următoarele opțiuni permite utilizarea variabilelor de mediu într-un container Kubernetes?",
        "answers": [
          { "text": "ConfigMap", "correct": true },
          { "text": "Ingress", "correct": false },
          { "text": "ReplicaSet", "correct": false }
        ]
      },
      {
        "question": "Ce comandă elimină un deployment Kubernetes?",
        "answers": [
          { "text": "kubectl delete deployment <deployment-name>", "correct": true },
          { "text": "kubectl remove deployment <deployment-name>", "correct": false },
          { "text": "kubectl destroy deployment <deployment-name>", "correct": false }
        ]
      },
      {
        "question": "Ce rol are kube-proxy în Kubernetes?",
        "answers": [
          { "text": "Gestionează rețelele și rutarea traficului către poduri", "correct": true },
          { "text": "Monitorizează utilizarea resurselor în cluster", "correct": false },
          { "text": "Automatizează crearea de noi noduri", "correct": false }
        ]
      },
      {
        "question": "Cum verificăm consumul de resurse al unui pod?",
        "answers": [
          { "text": "kubectl top pod <pod-name>", "correct": true },
          { "text": "kubectl describe pod <pod-name>", "correct": false },
          { "text": "kubectl logs pod <pod-name>", "correct": false }
        ]
      },
      {
        "question": "Ce obiect Kubernetes gestionează autentificarea și permisiunile utilizatorilor?",
        "answers": [
          { "text": "Role & RoleBinding", "correct": true },
          { "text": "ServiceAccount", "correct": false },
          { "text": "PersistentVolumeClaim", "correct": false }
        ]
      },
      {
        "question": "Ce comandă este utilizată pentru a vedea log-urile unui pod?",
        "answers": [
          { "text": "kubectl logs <pod-name>", "correct": true },
          { "text": "kubectl describe logs <pod-name>", "correct": false },
          { "text": "kubectl get logs <pod-name>", "correct": false }
        ]
      },
      {
        "question": "Ce este un StatefulSet în Kubernetes?",
        "answers": [
          { "text": "Un obiect care gestionează aplicații cu state persistent", "correct": true },
          { "text": "Un mecanism de autoscalare a podurilor", "correct": false },
          { "text": "Un obiect care rulează containere fără stare", "correct": false }
        ]
      },
      {
        "question": "Ce resursă Kubernetes este utilizată pentru a stoca date sensibile, cum ar fi parole?",
        "answers": [
          { "text": "Secret", "correct": true },
          { "text": "ConfigMap", "correct": false },
          { "text": "PersistentVolume", "correct": false }
        ]
      }
    ];

    const CC05 = [
      {
        "question": "Ce este Kubernetes?",
        "answers": [
          {
            "text": "Un orchestrator de containere pentru crearea, scalarea și managementul aplicațiilor",
            "correct": true
          },
          {
            "text": "Un limbaj de programare pentru dezvoltarea aplicațiilor web",
            "correct": false
          },
          {
            "text": "Un sistem de operare special pentru containere",
            "correct": false
          }
        ]
      },
      {
        "question": "Cine este responsabil pentru izolarea și securitatea aplicațiilor în Kubernetes?",
        "answers": [
          {
            "text": "Developerul sau sysadminul care gestionează clusterul",
            "correct": true
          },
          {
            "text": "Kubernetes aplică automat toate măsurile de securitate necesare",
            "correct": false
          },
          {
            "text": "Furnizorul de cloud",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum sunt resursele accesibile în mod implicit într-un cluster Kubernetes?",
        "answers": [
          {
            "text": "Majoritatea resurselor sunt accesibile între ele fără restricții stricte",
            "correct": true
          },
          {
            "text": "Fiecare pod este complet izolat de celelalte",
            "correct": false
          },
          {
            "text": "Accesul între resurse este blocat până la configurarea unui firewall",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce rol au cgroups în Kubernetes?",
        "answers": [
          {
            "text": "Controlează utilizarea resurselor precum CPU, memorie și I/O la nivel de container",
            "correct": true
          },
          {
            "text": "Oferă acces la dashboard-ul Kubernetes",
            "correct": false
          },
          {
            "text": "Asigură criptarea traficului de rețea",
            "correct": false
          }
        ]
      },
      {
        "question": "La ce se folosesc namespaces în Kubernetes?",
        "answers": [
          {
            "text": "Pentru izolarea proceselor și a sistemelor de fișiere",
            "correct": true
          },
          {
            "text": "Pentru distribuirea uniformă a podurilor între noduri",
            "correct": false
          },
          {
            "text": "Pentru stocarea persistentă a datelor",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este scopul rețelelor de tip network policies în Kubernetes?",
        "answers": [
          {
            "text": "Filtrarea traficului de rețea între poduri",
            "correct": true
          },
          {
            "text": "Monitorizarea resurselor consumate de containere",
            "correct": false
          },
          {
            "text": "Crearea de roluri pentru utilizatori",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce funcționalitate oferă RBAC în Kubernetes?",
        "answers": [
          {
            "text": "Controlul accesului la resursele din cluster bazat pe roluri",
            "correct": true
          },
          {
            "text": "Alocarea dinamică a resurselor hardware",
            "correct": false
          },
          {
            "text": "Configurarea politicilor de rețea",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este scopul principal al cgroups în Kubernetes?",
        "answers": [
          {
            "text": "Limitarea resurselor precum CPU, memorie și I/O la nivel de container",
            "correct": true
          },
          {
            "text": "Criptarea datelor stocate în containere",
            "correct": false
          },
          {
            "text": "Configurarea accesului utilizatorilor în cluster",
            "correct": false
          }
        ]
      },
      {
        "question": "De ce este importantă limitarea resurselor cu cgroups în Kubernetes?",
        "answers": [
          {
            "text": "Pentru a preveni ca un container să afecteze stabilitatea clusterului consumând toate resursele",
            "correct": true
          },
          {
            "text": "Pentru a crește viteza de rețea între poduri",
            "correct": false
          },
          {
            "text": "Pentru a permite containerelor să ruleze în paralel pe mai multe noduri",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum este implementat cgroups în Kubernetes?",
        "answers": [
          {
            "text": "La nivel de kernel Linux și expus prin runtime-ul de containere",
            "correct": true
          },
          {
            "text": "Ca o aplicație externă ce rulează în fiecare container",
            "correct": false
          },
          {
            "text": "Prin intermediul unui serviciu de rețea dedicat",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce înseamnă 'resources.requests' într-un manifest Kubernetes?",
        "answers": [
          {
            "text": "Resursele minime garantate de Kubernetes pentru rularea podului",
            "correct": true
          },
          {
            "text": "Resursele maxime pe care le poate folosi containerul",
            "correct": false
          },
          {
            "text": "Timpul maxim de execuție al containerului",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce definește 'resources.limits' în Kubernetes?",
        "answers": [
          {
            "text": "Resursele maxime pe care podul le poate folosi",
            "correct": true
          },
          {
            "text": "Numărul minim de replici pentru un deployment",
            "correct": false
          },
          {
            "text": "Intervalul de timp în care podul trebuie să pornească",
            "correct": false
          }
        ]
      },
      {
        "question": "Cu ce comandă putem vizualiza requests și limits ale unui pod în Kubernetes?",
        "answers": [
          {
            "text": "kubectl get pod webserver -o json | jq '.spec.containers[].resources'",
            "correct": true
          },
          {
            "text": "kubectl describe pod webserver --resources",
            "correct": false
          },
          {
            "text": "kubectl show resources webserver",
            "correct": false
          }
        ]
      },
      {
        "question": "La ce folosește comanda 'crictl inspect <container-id>'?",
        "answers": [
          {
            "text": "Pentru a inspecta detalii despre resursele alocate unui container în cgroups",
            "correct": true
          },
          {
            "text": "Pentru a porni un nou container în cluster",
            "correct": false
          },
          {
            "text": "Pentru a crea un pod nou pe control-plane",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce reprezintă valoarea 'quota' din rezultatul comenzii 'crictl inspect'?",
        "answers": [
          {
            "text": "Timpul maxim de CPU permis pentru container într-o perioadă definită",
            "correct": true
          },
          {
            "text": "Numărul total de poduri din cluster",
            "correct": false
          },
          {
            "text": "Timpul total de rulare al containerului în milisecunde",
            "correct": false
          }
        ]
      }, {
        "question": "Care este rolul principal al namespaces în Kubernetes?",
        "answers": [
          {
            "text": "Separarea logică între obiectele din cadrul unui cluster",
            "correct": true
          },
          {
            "text": "Crearea automată a podurilor și serviciilor",
            "correct": false
          },
          {
            "text": "Monitorizarea resurselor la nivel de container",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum ajută namespaces la organizarea mediilor de lucru?",
        "answers": [
          {
            "text": "Prin izolarea resurselor între medii precum development, staging și production",
            "correct": true
          },
          {
            "text": "Prin automatizarea testării aplicațiilor",
            "correct": false
          },
          {
            "text": "Prin creșterea performanței podurilor",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce resurse pot fi izolate folosind namespaces în Kubernetes?",
        "answers": [
          {
            "text": "Pods, services, deployments, config maps",
            "correct": true
          },
          {
            "text": "Volume mount points și kernel modules",
            "correct": false
          },
          {
            "text": "Fișiere locale din nodurile fizice",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum poate fi utilizat namespaces în contextul multi-tenancy?",
        "answers": [
          {
            "text": "Pentru a izola resursele între echipe sau clienți care folosesc același cluster",
            "correct": true
          },
          {
            "text": "Pentru a crește limita de memorie alocată containerelor",
            "correct": false
          },
          {
            "text": "Pentru a conecta containerele din namespace-uri diferite automat",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum pot fi izolate componentele unei aplicații folosind namespaces?",
        "answers": [
          {
            "text": "Fiecare componentă, precum frontend, backend și database, poate avea propriul namespace",
            "correct": true
          },
          {
            "text": "Fiecare componentă trebuie să ruleze în același namespace pentru compatibilitate",
            "correct": false
          },
          {
            "text": "Namespaces se folosesc doar pentru izolare între medii, nu între componente",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum putem crea o resursă într-un anumit namespace în Kubernetes?",
        "answers": [
          {
            "text": "Menționând namespace-ul în manifest sau folosind flag-ul -n în comanda kubectl",
            "correct": true
          },
          {
            "text": "Doar folosind comanda docker-compose",
            "correct": false
          },
          {
            "text": "Menționând numele podului în fișierul de configurare",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este comanda pentru a vizualiza toate namespace-urile dintr-un cluster Kubernetes?",
        "answers": [
          {
            "text": "kubectl get namespaces",
            "correct": true
          },
          {
            "text": "kubectl show ns",
            "correct": false
          },
          {
            "text": "kubectl list namespaces",
            "correct": false
          }
        ]
      },
      {
        "question": "Ce permite comanda 'kubectl config set-context --current --namespace=<namespace-name>'?",
        "answers": [
          {
            "text": "Setarea namespace-ului curent pentru comenzile kubectl",
            "correct": true
          },
          {
            "text": "Crearea unui nou namespace",
            "correct": false
          },
          {
            "text": "Ștergerea contextului actual",
            "correct": false
          }
        ]
      },
      {
        "question": "Este permisă în mod implicit comunicarea între poduri din namespace-uri diferite?",
        "answers": [
          {
            "text": "Da, Kubernetes permite comunicarea între poduri din namespace-uri diferite",
            "correct": true
          },
          {
            "text": "Nu, namespace-urile blochează complet comunicarea între poduri",
            "correct": false
          },
          {
            "text": "Doar dacă podurile au același nume",
            "correct": false
          }
        ]
      },
      {
        "question": "Cum poate fi limitat accesul între poduri aflate în namespace-uri diferite?",
        "answers": [
          {
            "text": "Prin utilizarea de network policies",
            "correct": true
          },
          {
            "text": "Prin redenumirea namespace-urilor",
            "correct": false
          },
          {
            "text": "Prin crearea de volume dedicate",
            "correct": false
          }
        ]
      },
      {
        "question": "Care este scopul principal al NetworkPolicies în Kubernetes?",
        "answers": [
          { "text": "Izolarea traficului de rețea între poduri și namespace-uri", "correct": true },
          { "text": "Actualizarea automată a containerelor", "correct": false },
          { "text": "Monitorizarea resurselor unui pod", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă nu există niciun NetworkPolicy aplicat într-un cluster Kubernetes?",
        "answers": [
          { "text": "Tot traficul este permis", "correct": true },
          { "text": "Tot traficul este blocat", "correct": false },
          { "text": "Doar traficul egress este permis", "correct": false }
        ]
      },
      {
        "question": "Ce element definește ce poduri sunt afectate de o NetworkPolicy?",
        "answers": [
          { "text": "podSelector", "correct": true },
          { "text": "policyTypes", "correct": false },
          { "text": "metadata.name", "correct": false }
        ]
      },
      {
        "question": "Care sunt cele două tipuri principale de trafic reglementate de NetworkPolicies?",
        "answers": [
          { "text": "Ingress și Egress", "correct": true },
          { "text": "Inbound și Outbound", "correct": false },
          { "text": "TCP și UDP", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă un selector gol în podSelector (adica `{}`)?",
        "answers": [
          { "text": "Se aplică tuturor podurilor din namespace", "correct": true },
          { "text": "Nu se aplică niciunui pod", "correct": false },
          { "text": "Se aplică doar podurilor default", "correct": false }
        ]
      },
      {
        "question": "Dacă într-o NetworkPolicy nu este specificată secțiunea ingress, ce se întâmplă?",
        "answers": [
          { "text": "Tot traficul de intrare este blocat", "correct": true },
          { "text": "Tot traficul este permis", "correct": false },
          { "text": "Se aplică doar regulile de egress", "correct": false }
        ]
      },
      {
        "question": "Ce rol are `policyTypes` în definirea unei NetworkPolicy?",
        "answers": [
          { "text": "Definește tipul de trafic afectat: Ingress și/sau Egress", "correct": true },
          { "text": "Alege namespace-ul vizat", "correct": false },
          { "text": "Specifică porturile TCP/UDP", "correct": false }
        ]
      },
      {
        "question": "NetworkPolicies sunt aditive. Ce înseamnă acest lucru?",
        "answers": [
          { "text": "Toate regulile se combină și traficul este permis dacă cel puțin una permite", "correct": true },
          { "text": "Se aplică doar prima politică definită", "correct": false },
          { "text": "Se aplică regula care restricționează cel mai mult traficul", "correct": false }
        ]
      },
      {
        "question": "Cum putem restricționa traficul între namespace-uri diferite?",
        "answers": [
          { "text": "Folosind namespaceSelector într-o NetworkPolicy", "correct": true },
          { "text": "Folosind config maps", "correct": false },
          { "text": "Prin modificarea fișierului kube-dns", "correct": false }
        ]
      },
      {
        "question": "Ce reprezintă `from` în secțiunea ingress a unei NetworkPolicy?",
        "answers": [
          { "text": "Sursele permise pentru traficul de intrare", "correct": true },
          { "text": "Destinațiile permise pentru traficul de ieșire", "correct": false },
          { "text": "Selectorul podurilor afectate", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă într-o NetworkPolicy lipsesc complet regulile de ingress și egress?",
        "answers": [
          { "text": "Tot traficul este blocat", "correct": true },
          { "text": "Tot traficul este permis", "correct": false },
          { "text": "Se blochează doar traficul de ieșire", "correct": false }
        ]
      },
      {
        "question": "Cum poate fi permis tot traficul de intrare într-un namespace folosind o NetworkPolicy?",
        "answers": [
          { "text": "Adăugând `ingress: - {}` în NetworkPolicy", "correct": true },
          { "text": "Folosind `policyTypes: - All`", "correct": false },
          { "text": "Omitând complet `ingress`", "correct": false }
        ]
      },
      {
        "question": "Ce indică `cluster.local` într-un URL intern Kubernetes?",
        "answers": [
          { "text": "Este sufixul DNS standard pentru resursele din cluster", "correct": true },
          { "text": "Este un pod din namespace-ul default", "correct": false },
          { "text": "Este un serviciu extern", "correct": false }
        ]
      },
      {
        "question": "Care este scopul portului specificat în NetworkPolicy?",
        "answers": [
          { "text": "Permite doar traficul pe acel port", "correct": true },
          { "text": "Blochează tot traficul pe acel port", "correct": false },
          { "text": "Este ignorat dacă selectorul este gol", "correct": false }
        ]
      },
      {
        "question": "Ce componentă DNS rezolvă adresele podurilor în Kubernetes?",
        "answers": [
          { "text": "kube-dns", "correct": true },
          { "text": "kube-proxy", "correct": false },
          { "text": "kubectl", "correct": false }
        ]
      },
      {
        "question": "Cum putem testa conectivitatea între poduri după aplicarea unei NetworkPolicy?",
        "answers": [
          { "text": "Folosind comanda curl între poduri", "correct": true },
          { "text": "Prin restartarea clusterului", "correct": false },
          { "text": "Prin kubectl logs", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă traficul 'East-West' în Kubernetes?",
        "answers": [
          { "text": "Trafic între poduri din același cluster", "correct": true },
          { "text": "Trafic între utilizatori și cluster", "correct": false },
          { "text": "Trafic între noduri externe", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă traficul 'North-South' în Kubernetes?",
        "answers": [
          { "text": "Trafic între cluster și exterior (internet, utilizatori)", "correct": true },
          { "text": "Trafic între poduri", "correct": false },
          { "text": "Trafic intern între noduri", "correct": false }
        ]
      },
      {
        "question": "Ce efect are lipsa câmpului `egress` într-o NetworkPolicy care specifică doar `policyTypes: [Egress]`?",
        "answers": [
          { "text": "Toate conexiunile de ieșire sunt blocate", "correct": true },
          { "text": "Toate conexiunile de ieșire sunt permise", "correct": false },
          { "text": "Nu are niciun efect", "correct": false }
        ]
      },
      {
        "question": "Poate o NetworkPolicy să blocheze explicit un anumit tip de trafic?",
        "answers": [
          { "text": "Nu, traficul este blocat doar în lipsa unei reguli care îl permite", "correct": true },
          { "text": "Da, dacă se folosește un câmp de tip `deny`", "correct": false },
          { "text": "Da, dacă se folosește `policyTypes: Deny`", "correct": false }
        ]
      },
      {
        "question": "Ce este RBAC în Kubernetes?",
        "answers": [
          { "text": "Un mecanism de control al accesului", "correct": true },
          { "text": "Un sistem de logare a erorilor", "correct": false },
          { "text": "Un instrument de monitorizare", "correct": false }
        ]
      },
      {
        "question": "Ce rol are RBAC într-un mediu zero-trust?",
        "answers": [
          { "text": "Permite accesul complet tuturor utilizatorilor", "correct": false },
          { "text": "Permite accesul doar la resursele necesare", "correct": true },
          { "text": "Blochează complet accesul la resurse", "correct": false }
        ]
      },
      {
        "question": "Ce resursă definește ce acțiuni pot fi efectuate asupra resurselor Kubernetes?",
        "answers": [
          { "text": "Role sau ClusterRole", "correct": true },
          { "text": "ServiceAccount", "correct": false },
          { "text": "Pod", "correct": false }
        ]
      },
      {
        "question": "Ce resursă leagă un rol de un utilizator sau service account?",
        "answers": [
          { "text": "RoleBinding sau ClusterRoleBinding", "correct": true },
          { "text": "Pod", "correct": false },
          { "text": "Deployment", "correct": false }
        ]
      },
      {
        "question": "Unde se aplică o resursă de tip Role?",
        "answers": [
          { "text": "Într-un singur namespace", "correct": true },
          { "text": "În toate namespace-urile", "correct": false },
          { "text": "Doar în namespace-ul default", "correct": false }
        ]
      },
      {
        "question": "Unde se aplică o resursă de tip ClusterRole?",
        "answers": [
          { "text": "La nivel de cluster", "correct": true },
          { "text": "Doar în namespace-ul default", "correct": false },
          { "text": "Într-un pod", "correct": false }
        ]
      },
      {
        "question": "Ce face un RoleBinding?",
        "answers": [
          { "text": "Leagă un rol de un utilizator într-un namespace", "correct": true },
          { "text": "Crează un pod nou", "correct": false },
          { "text": "Monitorizează resursele", "correct": false }
        ]
      },
      {
        "question": "Ce face un ClusterRoleBinding?",
        "answers": [
          { "text": "Leagă un ClusterRole de un utilizator la nivel de cluster", "correct": true },
          { "text": "Crează un nou namespace", "correct": false },
          { "text": "Conectează două poduri", "correct": false }
        ]
      },
      {
        "question": "Care este rolul unui ServiceAccount în Kubernetes?",
        "answers": [
          { "text": "Definește identitatea aplicațiilor care rulează în cluster", "correct": true },
          { "text": "Conectează utilizatorii între ei", "correct": false },
          { "text": "Stochează imagini Docker", "correct": false }
        ]
      },
      {
        "question": "Ce este montat automat în container pentru autentificare?",
        "answers": [
          { "text": "Un token JWT", "correct": true },
          { "text": "O cheie SSH", "correct": false },
          { "text": "Un fișier de configurare YAML", "correct": false }
        ]
      },
      {
        "question": "Ce comenzi folosim pentru a crea service accounts?",
        "answers": [
          { "text": "kubectl create serviceaccount", "correct": true },
          { "text": "kubectl apply sa", "correct": false },
          { "text": "kubectl init sa", "correct": false }
        ]
      },
      {
        "question": "Cum generăm un token pentru un service account?",
        "answers": [
          { "text": "kubectl -n <namespace> create token <serviceaccount>", "correct": true },
          { "text": "kubectl get secrets", "correct": false },
          { "text": "kubectl auth token", "correct": false }
        ]
      },
      {
        "question": "Ce definește secțiunea 'rules' într-un Role?",
        "answers": [
          { "text": "Ce resurse pot fi accesate și ce acțiuni pot fi făcute", "correct": true },
          { "text": "Ce utilizatori pot accesa Kubernetes", "correct": false },
          { "text": "Ce poduri rulează în namespace", "correct": false }
        ]
      },
      {
        "question": "Ce face comanda curl cu headerul Authorization: Bearer $DEV_TOKEN?",
        "answers": [
          { "text": "Trimite un request autentificat la API-ul Kubernetes", "correct": true },
          { "text": "Creează un nou token", "correct": false },
          { "text": "Listă utilizatorii din cluster", "correct": false }
        ]
      },
      {
        "question": "Ce fel de acțiuni poate executa utilizatorul 'alice' în exemplul oferit?",
        "answers": [
          { "text": "list și get pe pods și services", "correct": true },
          { "text": "delete pe deployments", "correct": false },
          { "text": "create pe pods", "correct": false }
        ]
      }
    ]

    const CC07 = [
      {
        "question": "Ce înseamnă acronimul CI/CD?",
        "answers": [
          { "text": "Continuous Integration/Continuous Delivery", "correct": true },
          { "text": "Cloud Infrastructure/Container Deployment", "correct": false },
          { "text": "Central Integration/Central Distribution", "correct": false }
        ]
      },
      {
        "question": "Care este scopul principal al unui workflow CI/CD?",
        "answers": [
          { "text": "Automatizarea livrării codului, de la testare până la deployment", "correct": true },
          { "text": "Scrierea codului sursă automat", "correct": false },
          { "text": "Crearea documentației pentru aplicație", "correct": false }
        ]
      },
      {
        "question": "Ce declanșează de obicei rularea unui pipeline CI/CD?",
        "answers": [
          { "text": "Un commit sau un pull request", "correct": true },
          { "text": "Un mesaj de la utilizator", "correct": false },
          { "text": "O eroare în aplicație", "correct": false }
        ]
      },
      {
        "question": "Ce poate reprezenta output-ul unui pipeline CI/CD?",
        "answers": [
          { "text": "Un artefact sau un nou deployment", "correct": true },
          { "text": "Un nou cod sursă", "correct": false },
          { "text": "Un test manual", "correct": false }
        ]
      },
      {
        "question": "Unde sunt definite acțiunile unui pipeline CI/CD?",
        "answers": [
          { "text": "Într-un fișier de configurare", "correct": true },
          { "text": "În codul aplicației", "correct": false },
          { "text": "În baza de date", "correct": false }
        ]
      },
      {
        "question": "Ce este un runner în contextul CI/CD?",
        "answers": [
          { "text": "Un VM sau container care rulează comenzile pipeline-ului", "correct": true },
          { "text": "Un utilizator care testează manual codul", "correct": false },
          { "text": "Un tip special de commit", "correct": false }
        ]
      },
      {
        "question": "Care este legătura dintre CI/CD și release-uri?",
        "answers": [
          { "text": "CI/CD este mecanismul prin care codul ajunge în producție", "correct": true },
          { "text": "CI/CD înlocuiește complet procesul de release", "correct": false },
          { "text": "CI/CD generează documentația pentru release", "correct": false }
        ]
      },
      {
        "question": "Ce este mediul de *development*?",
        "answers": [
          { "text": "Mediul unde se dezvoltă și se testează preliminar codul", "correct": true },
          { "text": "Mediul unde se fac testele finale înainte de release", "correct": false },
          { "text": "Mediul unde rulează aplicația finală", "correct": false }
        ]
      },
      {
        "question": "Ce caracterizează mediul de *staging*?",
        "answers": [
          { "text": "Simulează cât mai bine mediul de producție", "correct": true },
          { "text": "Este utilizat doar pentru backup-uri", "correct": false },
          { "text": "Este folosit pentru designul UI", "correct": false }
        ]
      },
      {
        "question": "Ce este mediul de *production*?",
        "answers": [
          { "text": "Mediul unde aplicația este livrată utilizatorilor reali", "correct": true },
          { "text": "Mediul folosit pentru testarea internă", "correct": false },
          { "text": "Un server temporar pentru debugging", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă reproductibilitatea într-un proces CI/CD?",
        "answers": [
          { "text": "Pași clari și replicabili pentru fiecare mediu și versiune", "correct": true },
          { "text": "Cod care funcționează doar pe mașina dezvoltatorului", "correct": false },
          { "text": "Testare manuală în fiecare etapă", "correct": false }
        ]
      },
      {
        "question": "De ce este important ca release-urile să aibă downtime minim?",
        "answers": [
          { "text": "Pentru ca aplicația să rămână disponibilă în timpul deploymentului", "correct": true },
          { "text": "Pentru a permite modificarea serverelor", "correct": false },
          { "text": "Pentru a închide aplicația temporar", "correct": false }
        ]
      },
      {
        "question": "Care este avantajul release-urilor automate?",
        "answers": [
          { "text": "Reducerea erorilor umane", "correct": true },
          { "text": "Crearea codului sursă automat", "correct": false },
          { "text": "Eliminarea completă a testelor", "correct": false }
        ]
      },
      {
        "question": "Ce este un rollback în CI/CD?",
        "answers": [
          { "text": "Revenirea la o versiune anterioară stabilă", "correct": true },
          { "text": "Eliminarea tuturor versiunilor aplicației", "correct": false },
          { "text": "Ștergerea codului sursă vechi", "correct": false }
        ]
      },
      {
        "question": "Care dintre următoarele este un tool popular de CI/CD?",
        "answers": [
          { "text": "GitHub Actions", "correct": true },
          { "text": "Postman", "correct": false },
          { "text": "Figma", "correct": false }
        ]
      }, {
        "question": "Ce presupune etapa de 'source code checkout' într-un pipeline CI/CD?",
        "answers": [
          { "text": "Preluarea codului sursă din repository și copierea în VM/container", "correct": true },
          { "text": "Testarea codului prin unit tests", "correct": false },
          { "text": "Compilarea codului în binar", "correct": false }
        ]
      },
      {
        "question": "Care este scopul etapei de compilare într-un pipeline CI/CD?",
        "answers": [
          { "text": "Obținerea binarului și detectarea erorilor de compilare", "correct": true },
          { "text": "Scrierea codului în repository", "correct": false },
          { "text": "Executarea testelor unitare", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă în etapa de testare automată a unui pipeline CI/CD?",
        "answers": [
          { "text": "Se execută teste automate pentru a identifica buguri de logică sau funcționalitate", "correct": true },
          { "text": "Se publică imaginea de Docker", "correct": false },
          { "text": "Se compilează codul sursă", "correct": false }
        ]
      },
      {
        "question": "Ce reprezintă publicarea artefactelor într-un pipeline CI/CD?",
        "answers": [
          { "text": "Publicarea aplicației sub formă de Docker image, executabil sau bibliotecă", "correct": true },
          { "text": "Testarea codului cu utilizatori reali", "correct": false },
          { "text": "Scrierea fișierului de configurare", "correct": false }
        ]
      },
      {
        "question": "Ce presupune etapa de deployment în producție într-un pipeline CI/CD?",
        "answers": [
          { "text": "Livrarea aplicației către utilizatori finali, dacă este necesar", "correct": true },
          { "text": "Scrierea codului în repository", "correct": false },
          { "text": "Crearea unui branch nou în Git", "correct": false }
        ]
      },
      {
        "question": "Cum poate fi folosit CI/CD pentru verificarea stilului de cod?",
        "answers": [
          { "text": "Prin rularea de lintere sau checkere, precum checkpatch.pl", "correct": true },
          { "text": "Prin publicarea imaginilor Docker", "correct": false },
          { "text": "Prin rularea testelor manuale", "correct": false }
        ]
      },
      {
        "question": "Ce rol are CI/CD în rularea scripturilor de configurare?",
        "answers": [
          { "text": "Automatizează pași precum migrarea bazelor de date", "correct": true },
          { "text": "Ajută la scrierea de documentație tehnică", "correct": false },
          { "text": "Optimizează interfața aplicației", "correct": false }
        ]
      },
      {
        "question": "Care dintre următoarele este un use case comun pentru CI/CD?",
        "answers": [
          { "text": "Compilarea codului și build-uirea imaginilor Docker", "correct": true },
          { "text": "Crearea de conturi pentru utilizatori", "correct": false },
          { "text": "Monitorizarea traficului rețelei", "correct": false }
        ]
      },
      {
        "question": "Ce este un workflow în contextul GitHub Actions?",
        "answers": [
          { "text": "Un set de acțiuni care se execută la un anumit eveniment", "correct": true },
          { "text": "Un fișier de configurare pentru setările IDE-ului", "correct": false },
          { "text": "Un container Docker folosit pentru testare", "correct": false }
        ]
      },
      {
        "question": "Ce este un job în cadrul unui workflow GitHub Actions?",
        "answers": [
          { "text": "Un set de pași executat pe un anumit runner", "correct": true },
          { "text": "Un test de performanță automat", "correct": false },
          { "text": "Un tip de fișier de configurare", "correct": false }
        ]
      },
      {
        "question": "Ce definește un step într-un job GitHub Actions?",
        "answers": [
          { "text": "O acțiune individuală, cum ar fi checkout sau run", "correct": true },
          { "text": "O variabilă globală", "correct": false },
          { "text": "O versiune de cod", "correct": false }
        ]
      },
      {
        "question": "Ce eveniment declanșează workflow-ul în exemplul dat?",
        "answers": [
          { "text": "Un push pe branch-ul main", "correct": true },
          { "text": "Un merge în orice branch", "correct": false },
          { "text": "Un comentariu într-un pull request", "correct": false }
        ]
      },
      {
        "question": "Ce face comanda `actions/checkout@v4` în pipeline?",
        "answers": [
          { "text": "Clonează codul sursă din repository", "correct": true },
          { "text": "Instalează toate dependințele Go", "correct": false },
          { "text": "Rulează testele definite în cod", "correct": false }
        ]
      },
      {
        "question": "Care este avantajul principal al GitHub Actions ca soluție CI/CD?",
        "answers": [
          { "text": "Este complet integrat cu ecosistemul GitHub și nu necesită setarea infrastructurii", "correct": true },
          { "text": "Permite testarea manuală direct din browser", "correct": false },
          { "text": "Oferă suport complet pentru orice sistem de operare", "correct": false }
        ]
      },
      {
        "question": "Care este unul dintre dezavantajele majore ale GitHub Actions?",
        "answers": [
          { "text": "Debugging-ul este dificil pe pipeline-uri complexe", "correct": true },
          { "text": "Nu poate compila cod scris în Go", "correct": false },
          { "text": "Necesită licență plătită pentru rulare", "correct": false }
        ]
      },
      {
        "question": "Ce face comanda `go mod download` în pipeline?",
        "answers": [
          { "text": "Instalează toate dependințele specificate în fișierul go.mod", "correct": true },
          { "text": "Rulează testele aplicației", "correct": false },
          { "text": "Construiește imaginea Docker a aplicației", "correct": false }
        ]
      },
      {
        "question": "Ce rol are GitHub Marketplace în contextul GitHub Actions?",
        "answers": [
          { "text": "Permite reutilizarea de acțiuni gata făcute", "correct": true },
          { "text": "Stochează imaginile Docker construite", "correct": false },
          { "text": "Administrează utilizatorii care rulează workflow-ul", "correct": false }
        ]
      },
      {
        "question": "Ce este GHCR în contextul GitHub Actions?",
        "answers": [
          { "text": "Un registry pentru stocarea și distribuirea imaginilor Docker", "correct": true },
          { "text": "Un fișier de configurare pentru runners", "correct": false },
          { "text": "O extensie pentru rularea aplicației în browser", "correct": false }
        ]
      },
      {
        "question": "Ce comandă creează un cluster Kubernetes local folosind kind?",
        "answers": [
          { "text": "kind create cluster", "correct": true },
          { "text": "kubectl create cluster", "correct": false },
          { "text": "kind init", "correct": false }
        ]
      },
      {
        "question": "Ce comandă instalează Argo CD într-un namespace dedicat?",
        "answers": [
          { "text": "kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml", "correct": true },
          { "text": "kubectl install argocd", "correct": false },
          { "text": "kubectl setup argo", "correct": false }
        ]
      },
      {
        "question": "Ce resurse sunt afișate prin comanda `kubectl get all -n argocd`?",
        "answers": [
          { "text": "Toate resursele din namespace-ul argocd", "correct": true },
          { "text": "Doar pod-urile Argo CD", "correct": false },
          { "text": "Resursele din toate namespace-urile", "correct": false }
        ]
      },
      {
        "question": "Ce definește un manifest Argo CD de tip `Application`?",
        "answers": [
          { "text": "Configurarea aplicației ce va fi sincronizată și rulată de Argo", "correct": true },
          { "text": "O bază de date în Kubernetes", "correct": false },
          { "text": "Un container pentru rularea testelor", "correct": false }
        ]
      },
      {
        "question": "Ce comandă creează un namespace în Kubernetes pentru Argo CD?",
        "answers": [
          { "text": "kubectl create namespace argocd", "correct": true },
          { "text": "argo create namespace argocd", "correct": false },
          { "text": "kubectl apply argocd-ns.yaml", "correct": false }
        ]
      },
      {
        "question": "Ce scop are comanda `kubectl port-forward svc/argocd-server -n argocd 8080:443`?",
        "answers": [
          { "text": "Deschide acces local către dashboard-ul Argo CD", "correct": true },
          { "text": "Expune serviciul webserver în Internet", "correct": false },
          { "text": "Crează o legătură între două namespace-uri", "correct": false }
        ]
      },
      {
        "question": "Cum se obține parola de admin generată automat pentru Argo CD?",
        "answers": [
          { "text": "Prin extragere din secretul `argocd-initial-admin-secret`", "correct": true },
          { "text": "Prin rularea comenzii `argocd get password`", "correct": false },
          { "text": "Este setată implicit ca 'admin123'", "correct": false }
        ]
      },
      {
        "question": "Ce comandă listează aplicațiile gestionate de Argo CD?",
        "answers": [
          { "text": "argocd app list", "correct": true },
          { "text": "argocd list apps", "correct": false },
          { "text": "argocd apps show", "correct": false }
        ]
      },
      {
        "question": "Ce comandă afișează resursele asociate unei aplicații Argo CD?",
        "answers": [
          { "text": "argocd app resources go-simple-webserver", "correct": true },
          { "text": "kubectl get app go-simple-webserver", "correct": false },
          { "text": "argo list resources", "correct": false }
        ]
      },
      {
        "question": "Cum se creează o aplicație în Argo CD folosind CLI?",
        "answers": [
          { "text": "argocd app create go-simple-webserver ...", "correct": true },
          { "text": "argo app init go-simple-webserver ...", "correct": false },
          { "text": "kubectl create app go-simple-webserver", "correct": false }
        ]
      },
      {
        "question": "Ce imagine Docker este folosită în exemplul de manifest Deployment?",
        "answers": [
          { "text": "ghcr.io/andreia-oca/go-simple-webserver:latest", "correct": true },
          { "text": "docker.io/go/simple-webserver:latest", "correct": false },
          { "text": "hub.docker.com/andreia/webserver", "correct": false }
        ]
      },
      {
        "question": "Ce rol are `syncPolicy` în manifestul aplicației Argo CD?",
        "answers": [
          { "text": "Controlează sincronizarea automată și comportamentul de self-heal", "correct": true },
          { "text": "Setează numărul de replici pentru aplicație", "correct": false },
          { "text": "Configurează dashboard-ul Argo", "correct": false }
        ]
      },
      {
        "question": "Ce face opțiunea `prune: true` în cadrul `syncPolicy`?",
        "answers": [
          { "text": "Elimină resursele care nu mai sunt definite în manifests", "correct": true },
          { "text": "Șterge istoricul sincronizărilor", "correct": false },
          { "text": "Resetează aplicația la ultima versiune validă", "correct": false }
        ]
      },
      {
        "question": "Ce face comanda `argocd app sync go-simple-webserver`?",
        "answers": [
          { "text": "Forțează sincronizarea aplicației cu manifestele din Git", "correct": true },
          { "text": "Deschide dashboard-ul Argo în browser", "correct": false },
          { "text": "Repornește aplicația în Kubernetes", "correct": false }
        ]
      },
      {
        "question": "Ce beneficiu oferă dashboard-ul Argo CD?",
        "answers": [
          { "text": "Monitorizarea aplicațiilor și starea podurilor gestionate de Argo", "correct": true },
          { "text": "Editarea fișierelor manifest direct în cluster", "correct": false },
          { "text": "Crearea de utilizatori pentru Kubernetes", "correct": false }
        ]
      },
      {
        "question": "Ce reprezintă strategia Canary/Rollout în contextul deploymentului?",
        "answers": [
          { "text": "Un deployment care se face în etape, începând cu un număr mic de utilizatori", "correct": true },
          { "text": "Un deployment care rulează doar pe medii de test", "correct": false },
          { "text": "Un deployment realizat doar în afara orelor de vârf", "correct": false }
        ]
      },
      {
        "question": "Care este principalul avantaj al utilizării strategiei Canary/Rollout?",
        "answers": [
          { "text": "Permite monitorizarea stabilității aplicației fără a afecta toți utilizatorii", "correct": true },
          { "text": "Reduce costurile de infrastructură", "correct": false },
          { "text": "Grăbește procesul de deployment", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă în cazul unui bug într-un deployment de tip Canary?",
        "answers": [
          { "text": "Doar o mică parte dintre utilizatori sunt afectați", "correct": true },
          { "text": "Toți utilizatorii pierd accesul la aplicație", "correct": false },
          { "text": "Deploymentul se oprește automat", "correct": false }
        ]
      },
      {
        "question": "Cum funcționează strategia Blue/Green deployment în Kubernetes?",
        "answers": [
          { "text": "Se creează un deployment nou (green), se verifică sănătatea acestuia și apoi se mută traficul de la versiunea veche (blue)", "correct": true },
          { "text": "Se șterge versiunea veche și se lansează cea nouă", "correct": false },
          { "text": "Se rulează ambele versiuni în paralel pentru totdeauna", "correct": false }
        ]
      },
      {
        "question": "Ce presupune pasul de „promovare a deploymentului” într-un Blue/Green deployment?",
        "answers": [
          { "text": "Redirecționarea traficului de la blue la green", "correct": true },
          { "text": "Testarea codului sursă în mediu local", "correct": false },
          { "text": "Revenirea la versiunea anterioară", "correct": false }
        ]
      },
      {
        "question": "Cum este evitat downtime-ul în strategia Blue/Green deployment?",
        "answers": [
          { "text": "Prin mutarea traficului doar după ce noua versiune e verificată", "correct": true },
          { "text": "Prin oprirea tuturor serviciilor și repornirea lor", "correct": false },
          { "text": "Prin rularea aplicației pe un singur server", "correct": false }
        ]
      },
      {
        "question": "Ce este un rollback în contextul deploymentului?",
        "answers": [
          { "text": "Procesul de revenire la o versiune anterioară stabilă", "correct": true },
          { "text": "Crearea unui nou branch de dezvoltare", "correct": false },
          { "text": "Testarea aplicației pe serverul de backup", "correct": false }
        ]
      },
      {
        "question": "Cum poate fi realizat un rollback într-un Blue/Green deployment?",
        "answers": [
          { "text": "Schimbând traficul înapoi la deploymentul vechi (blue)", "correct": true },
          { "text": "Recompilând codul aplicației", "correct": false },
          { "text": "Creând o nouă aplicație cu un alt nume", "correct": false }
        ]
      },
      {
        "question": "De ce este important să avem un mecanism de rollback în pipeline-urile de deployment?",
        "answers": [
          { "text": "Pentru a reduce downtime-ul și a menține stabilitatea aplicației", "correct": true },
          { "text": "Pentru a îmbunătăți viteza de build", "correct": false },
          { "text": "Pentru a înlocui procesul de testare manuală", "correct": false }
        ]
      },
      {
        "question": "Ce reprezintă 'setWeight' într-un rollout deployment?",
        "answers": [
          { "text": "Procentul de trafic redirecționat către noile poduri", "correct": true },
          { "text": "Numărul de poduri create inițial", "correct": false },
          { "text": "Timpul de așteptare între etapele de rollout", "correct": false }
        ]
      },
      {
        "question": "Care este rolul 'pause' într-un rollout deployment?",
        "answers": [
          { "text": "Definește durata de așteptare înainte de a trece la următorul procentaj de trafic", "correct": true },
          { "text": "Oprește definitiv procesul de deployment", "correct": false },
          { "text": "Resetează configurația deploymentului", "correct": false }
        ]
      },
      {
        "question": "Când este considerat complet un rollout deployment?",
        "answers": [
          { "text": "Când 100% din trafic este redirecționat către noua versiune a aplicației", "correct": true },
          { "text": "Când toate podurile sunt în stare Running", "correct": false },
          { "text": "Când a fost creat primul pod", "correct": false }
        ]
      },
      {
        "question": "Ce comandă se folosește pentru a monitoriza un rollout deployment în timp real?",
        "answers": [
          { "text": "argo-rollouts get rollout go-simple-webserver --watch", "correct": true },
          { "text": "kubectl describe deployment go-simple-webserver", "correct": false },
          { "text": "kubectl rollout history", "correct": false }
        ]
      },
      {
        "question": "Ce comandă se folosește pentru a promova manual un rollout?",
        "answers": [
          { "text": "argo-rollouts promote go-simple-webserver", "correct": true },
          { "text": "kubectl apply --force", "correct": false },
          { "text": "argo sync --manual", "correct": false }
        ]
      }
    ]

    const CC08 = [
      {
        "question": "Ce reprezintă datele într-un context de data pipelines?",
        "answers": [
          { "text": "Evenimente precum tranzacții, logări sau loguri de securitate", "correct": true },
          { "text": "Fișiere statice cu informații arhivate", "correct": false },
          { "text": "Documentația aplicației", "correct": false }
        ]
      },
      {
        "question": "Ce poate fi considerat un exemplu de eveniment într-un data pipeline?",
        "answers": [
          { "text": "O tranzacție online sau un log de securitate", "correct": true },
          { "text": "Un fișier PDF descărcat de pe internet", "correct": false },
          { "text": "Un cod sursă scris într-un IDE", "correct": false }
        ]
      },
      {
        "question": "Care dintre următoarele reprezintă un use case pentru data pipelines?",
        "answers": [
          { "text": "Managementul securității", "correct": true },
          { "text": "Crearea interfeței grafice", "correct": false },
          { "text": "Redactarea documentației", "correct": false }
        ]
      },
      {
        "question": "Ce alt use case este menționat pentru data pipelines?",
        "answers": [
          { "text": "Gestiunea tranzacțiilor în e-commerce", "correct": true },
          { "text": "Configurarea setărilor aplicației", "correct": false },
          { "text": "Criptarea parolelor", "correct": false }
        ]
      },
      {
        "question": "Pe ce componentă a procesării datelor se concentrează cursul?",
        "answers": [
          { "text": "Agregarea informației", "correct": true },
          { "text": "Stilizarea interfeței", "correct": false },
          { "text": "Testarea automată", "correct": false }
        ]
      },
      {
        "question": "Ce caracterizează o arhitectură bazată pe micro-servicii?",
        "answers": [
          { "text": "Aplicația este împărțită în servicii independente", "correct": true },
          { "text": "Codul este scris într-un singur fișier principal", "correct": false },
          { "text": "Toate componentele rulează pe același server", "correct": false }
        ]
      },
      {
        "question": "Un avantaj al microserviciilor este:",
        "answers": [
          { "text": "Posibilitatea de a actualiza o componentă fără a afecta celelalte", "correct": true },
          { "text": "Reducerea nevoii de testare", "correct": false },
          { "text": "Eliminarea completă a bugurilor", "correct": false }
        ]
      },
      {
        "question": "Cum pot comunica microserviciile între ele?",
        "answers": [
          { "text": "Prin endpointuri, cum ar fi un API RESTful", "correct": true },
          { "text": "Prin fișiere text partajate", "correct": false },
          { "text": "Prin conexiuni directe la bazele de date", "correct": false }
        ]
      },
      {
        "question": "Care este o problemă a comunicării prin API RESTful între microservicii?",
        "answers": [
          { "text": "Crește gradul de cuplare între servicii", "correct": true },
          { "text": "Consumă mai puțină memorie", "correct": false },
          { "text": "Este mai sigură decât alte metode", "correct": false }
        ]
      },
      {
        "question": "Ce problemă apare dacă vrem să colectăm analitici despre evenimente într-un sistem clasic?",
        "answers": [
          { "text": "Trebuie să adăugăm manual apeluri către sistemul de analitici", "correct": true },
          { "text": "Se pierd toate datele de tranzacție", "correct": false },
          { "text": "Nu putem trimite date între servicii", "correct": false }
        ]
      },
      {
        "question": "De ce nu este scalabil modul naiv de integrare între microservicii?",
        "answers": [
          { "text": "Crește complexitatea și code base-ul", "correct": true },
          { "text": "Funcționează doar pe Linux", "correct": false },
          { "text": "Consumă prea multă memorie RAM", "correct": false }
        ]
      },
      {
        "question": "Ce soluție este sugerată pentru a permite procesarea scalabilă a evenimentelor?",
        "answers": [
          { "text": "Transformarea sistemului într-un sistem de logging la care alte servicii se pot abona", "correct": true },
          { "text": "Crearea unei aplicații monolitice", "correct": false },
          { "text": "Refactorizarea tuturor componentelor simultan", "correct": false }
        ]
      },
      {
        "question": "Care este scopul principal al logării evenimentelor?",
        "answers": [
          { "text": "Sprijinirea deciziilor de business sau billing", "correct": true },
          { "text": "Îmbunătățirea designului interfeței", "correct": false },
          { "text": "Reducerea consumului de memorie", "correct": false }
        ]
      },
      {
        "question": "Ce tip de structură poate reprezenta logarea evenimentelor în cloud computing?",
        "answers": [
          { "text": "O bază de date append-only", "correct": true },
          { "text": "Un fișier XML distribuit", "correct": false },
          { "text": "O rețea peer-to-peer", "correct": false }
        ]
      },
      {
        "question": "Care este o problemă a bazelor de date tradiționale în contextul procesării de evenimente?",
        "answers": [
          { "text": "Nu scalează bine pe mai multe noduri", "correct": true },
          { "text": "Nu pot stoca date text", "correct": false },
          { "text": "Necesită hardware dedicat", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă scalare verticală la bazele de date?",
        "answers": [
          { "text": "Creșterea performanței unui singur nod", "correct": true },
          { "text": "Adăugarea de noduri suplimentare", "correct": false },
          { "text": "Replicarea automată a datelor", "correct": false }
        ]
      },
      {
        "question": "Care este o alternativă la bazele de date pentru procesarea evenimentelor?",
        "answers": [
          { "text": "Sisteme de message passing (message queues)", "correct": true },
          { "text": "Procesoare de imagini", "correct": false },
          { "text": "Servicii DNS", "correct": false }
        ]
      },
      {
        "question": "Ce rol au sistemele de tip message passing în arhitecturi distribuite precum OpenStack?",
        "answers": [
          { "text": "Facilitează comunicarea între componente prin evenimente", "correct": true },
          { "text": "Înlocuiesc bazele de date relaționale", "correct": false },
          { "text": "Găzduiesc interfețele grafice", "correct": false }
        ]
      },
      {
        "question": "Care este o limitare importantă a sistemelor de tip message queue?",
        "answers": [
          { "text": "Evenimentele dispar după ce sunt consumate", "correct": true },
          { "text": "Nu pot trimite date între noduri", "correct": false },
          { "text": "Necesită conexiune constantă la internet", "correct": false }
        ]
      },
      {
        "question": "De ce nu este suficient un message queue dacă avem mai mulți consumatori?",
        "answers": [
          { "text": "Evenimentul este eliminat după primul consum", "correct": true },
          { "text": "Se dublează automat toate mesajele", "correct": false },
          { "text": "Este incompatibil cu REST APIs", "correct": false }
        ]
      },
      {
        "question": "Ce dezavantaj au MQ-urile în contextul istoricelor de evenimente?",
        "answers": [
          { "text": "Nu stochează un istoric al mesajelor", "correct": true },
          { "text": "Necesită autentificare biometrică", "correct": false },
          { "text": "Generează erori în rețele WiFi", "correct": false }
        ]
      },
      {
        "question": "Ce rol are un broker în arhitectura Apache Kafka?",
        "answers": [
          { "text": "Controlează și gestionează cozile de mesaje (topicuri)", "correct": true },
          { "text": "Inserează mesaje în cozi", "correct": false },
          { "text": "Consumă mesaje din cozi", "correct": false }
        ]
      },
      {
        "question": "Ce funcție are un producer în Kafka?",
        "answers": [
          { "text": "Aplică algoritmi de hashing pe mesaje", "correct": false },
          { "text": "Aplică politici de retenție a mesajelor", "correct": false },
          { "text": "Aplicăția care inserează mesaje în cozi (topicuri)", "correct": true }
        ]
      },
      {
        "question": "Ce face un consumer în Kafka?",
        "answers": [
          { "text": "Accesează și procesează mesaje din cozi (topicuri)", "correct": true },
          { "text": "Trimite mesaje către brokeri", "correct": false },
          { "text": "Monitorizează starea clusterei", "correct": false }
        ]
      },
      {
        "question": "Ce soluție este necesară pentru a putea interoga evenimentele pe termen lung?",
        "answers": [
          { "text": "Agregarea evenimentelor într-un mediu de stocare permanent", "correct": true },
          { "text": "Folosirea directă a API-urilor REST", "correct": false },
          { "text": "Înlocuirea MQ-urilor cu baze de date relaționale", "correct": false }
        ]
      },
      {
        "question": "Ce este Apache Kafka și care este scopul său principal?",
        "answers": [
          { "text": "Este un sistem care procesează datele direct", "correct": false },
          { "text": "Este un instrument care facilitează procesarea datelor prin stocarea și transmiterea mesajelor", "correct": true },
          { "text": "Este un API pentru baze de date relaționale", "correct": false }
        ]
      },
      {
        "question": "Ce rol joacă file system-ul în Kafka?",
        "answers": [
          { "text": "Este folosit doar temporar pentru cache", "correct": false },
          { "text": "Este locul unde Kafka stochează persistent evenimentele", "correct": true },
          { "text": "Este folosit pentru a procesa mesajele", "correct": false }
        ]
      },
      {
        "question": "Ce garanție oferă Kafka pentru stocarea datelor?",
        "answers": [
          { "text": "Datele sunt replicate și persistate pe disc", "correct": true },
          { "text": "Datele sunt stocate doar în memorie", "correct": false },
          { "text": "Datele sunt criptate dar nu replicate", "correct": false }
        ]
      },
      {
        "question": "Care sunt cele trei componente principale ale arhitecturii Kafka?",
        "answers": [
          { "text": "Topic, Partition, Cluster", "correct": false },
          { "text": "Broker, Producer, Consumer", "correct": true },
          { "text": "Client, Server, Database", "correct": false }
        ]
      },
      {
        "question": "Ce este un topic în Kafka?",
        "answers": [
          { "text": "Un fișier de configurare pentru mesaje", "correct": false },
          { "text": "O coadă de evenimente asociată unui anumit tip de date", "correct": true },
          { "text": "Un script care procesează loguri", "correct": false }
        ]
      },
      {
        "question": "Cum permite Kafka scalarea orizontală?",
        "answers": [
          { "text": "Prin partiționarea topicurilor între brokeri", "correct": true },
          { "text": "Prin dublarea nodurilor vertical", "correct": false },
          { "text": "Prin replicarea mesajelor doar pe un singur nod", "correct": false }
        ]
      },
      {
        "question": "Care este rolul unei partiții în Kafka?",
        "answers": [
          { "text": "Să izoleze consumatorii", "correct": false },
          { "text": "Să împartă un topic pe mai mulți brokeri", "correct": true },
          { "text": "Să cripteze mesajele", "correct": false }
        ]
      },
      {
        "question": "Cum sunt distribuite mesajele în partițiile Kafka?",
        "answers": [
          { "text": "Aleatoriu", "correct": false },
          { "text": "Pe baza unei chei sau a unui algoritm de hashing", "correct": true },
          { "text": "Manual de către administrator", "correct": false }
        ]
      },
      {
        "question": "Ce avantaj aduce replicarea mesajelor în Kafka?",
        "answers": [
          { "text": "Reduce dimensiunea datelor", "correct": false },
          { "text": "Permite redundanță și disponibilitate în caz de failure", "correct": true },
          { "text": "Crește viteza de scriere", "correct": false }
        ]
      },
      {
        "question": "Câți brokeri sunt recomandați într-un cluster Kafka complet?",
        "answers": [
          { "text": "1", "correct": false },
          { "text": "2", "correct": false },
          { "text": "Minim 3", "correct": true }
        ]
      },
      {
        "question": "Cum se abonează un consumer la un topic Kafka?",
        "answers": [
          { "text": "Folosind API-ul Kafka", "correct": true },
          { "text": "Editând fișierele de configurare", "correct": false },
          { "text": "Prin comenzi CLI", "correct": false }
        ]
      },
      {
        "question": "Ce dezavantaj are conectarea naivă a unui consumer la un topic?",
        "answers": [
          { "text": "Consumatorii nu pot primi mesaje", "correct": false },
          { "text": "Nu se paralelizează procesarea datelor", "correct": true },
          { "text": "Se pierd mesajele la conectare", "correct": false }
        ]
      },
      {
        "question": "Care este scopul grupurilor de consumatori în Kafka?",
        "answers": [
          { "text": "Să trimită mesaje simultan la producători", "correct": false },
          { "text": "Să proceseze evenimente fără suprapunere între consumatori", "correct": true },
          { "text": "Să stocheze logurile local", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă numărul de consumatori dintr-un grup depășește numărul de partiții?",
        "answers": [
          { "text": "Toți consumatorii vor primi mesaje simultan", "correct": false },
          { "text": "Consumatorii în plus nu vor procesa mesaje", "correct": true },
          { "text": "Se vor crea automat mai multe partiții", "correct": false }
        ]
      },
      {
        "question": "Ce avantaj oferă folosirea consumatorilor în plus față de numărul de partiții?",
        "answers": [
          { "text": "Reduc dimensiunea mesajelor", "correct": false },
          { "text": "Asigură redundanță în caz de eșec al altor consumatori", "correct": true },
          { "text": "Accelerează scrierea mesajelor", "correct": false }
        ]
      },
      {
        "question": "Cum contribuie Kafka la un sistem highly available?",
        "answers": [
          { "text": "Prin transmiterea în direct a mesajelor", "correct": false },
          { "text": "Prin replicarea mesajelor pe mai mulți brokeri", "correct": true },
          { "text": "Prin eliminarea partițiilor", "correct": false }
        ]
      },
      {
        "question": "Ce este un broker în Kafka?",
        "answers": [
          { "text": "Un client de configurare", "correct": false },
          { "text": "Un nod care gestionează topicuri și mesaje", "correct": true },
          { "text": "Un sistem de criptare", "correct": false }
        ]
      },
      {
        "question": "Ce rol are un producer în Kafka?",
        "answers": [
          { "text": "Primește mesaje de la consumatori", "correct": false },
          { "text": "Trimite mesaje în topicuri", "correct": true },
          { "text": "Administrează replicarea", "correct": false }
        ]
      },
      {
        "question": "Ce tip de garanție de performanță oferă Kafka pentru inserturi?",
        "answers": [
          { "text": "Inserări la intervale de câteva secunde", "correct": false },
          { "text": "Inserări la nivel de sub o secundă", "correct": true },
          { "text": "Inserări asincrone garantate după 1 minut", "correct": false }
        ]
      },
      {
        "question": "Cum evită Kafka fenomenul de hostspotting?",
        "answers": [
          { "text": "Prin reducerea dimensiunii mesajelor", "correct": false },
          { "text": "Prin distribuirea evenimentelor între mai mulți brokeri", "correct": true },
          { "text": "Prin trimiterea mesajelor doar noaptea", "correct": false }
        ]
      }
    ];

    const CC09 = [
      {
        "question": "Care este rolul principal al volumelor în Kubernetes?",
        "answers": [
          { "text": "Împărțirea fișierelor între containere din același pod", "correct": true },
          { "text": "Stocarea persistentă a datelor pe termen lung", "correct": false },
          { "text": "Limitarea resurselor alocate containerelor", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă cu datele dintr-un volum obișnuit după ștergerea podului în Kubernetes?",
        "answers": [
          { "text": "Datele sunt șterse împreună cu podul", "correct": true },
          { "text": "Datele sunt salvate automat într-un PersistentVolume", "correct": false },
          { "text": "Datele sunt transferate altui pod automat", "correct": false }
        ]
      },
      {
        "question": "Ce caracterizează un volum obișnuit în Kubernetes (non-persistent)?",
        "answers": [
          { "text": "Este folosit pentru a partaja fișiere între containere din același pod", "correct": true },
          { "text": "Este legat direct de un disk fizic permanent", "correct": false },
          { "text": "Persistă automat datele în cloud", "correct": false }
        ]
      },
      {
        "question": "Ce definește folosirea aceluiași volum de către mai multe containere într-un pod?",
        "answers": [
          { "text": "Toate containerele folosesc același nume de volum și montează la căi diferite", "correct": true },
          { "text": "Fiecare container are nevoie de un volum diferit", "correct": false },
          { "text": "Volumul trebuie duplicat pentru fiecare container", "correct": false }
        ]
      },
      {
        "question": "De ce este considerat ineficient setup-ul cu două containere pentru clonare și servire?",
        "answers": [
          { "text": "Există metode mai bune de a pregăti mediul pentru container", "correct": true },
          { "text": "Git nu funcționează bine în containere", "correct": false },
          { "text": "nginx nu poate servi fișiere HTML", "correct": false }
        ]
      },
      {
        "question": "Care este scopul folosirii volumelor în exemplul cu nginx și git?",
        "answers": [
          { "text": "Partajarea fișierelor între containere pentru a servi un site web", "correct": true },
          { "text": "Salvarea permanentă a codului clonat", "correct": false },
          { "text": "Instalarea nginx în ambele containere", "correct": false }
        ]
      },
      {
        "question": "Ce limitare are un Ingress în Kubernetes în ceea ce privește namespace-urile?",
        "answers": [
          { "text": "Poate face load balancing doar în interiorul unui namespace", "correct": true },
          { "text": "Poate accesa orice serviciu din orice namespace", "correct": false },
          { "text": "Este folosit pentru configurarea rețelei între noduri", "correct": false }
        ]
      },
      {
        "question": "De ce nu mai este suficient să configurăm serviciile în containere prin bind mount, ca în Docker?",
        "answers": [
          { "text": "Pentru că podurile nu sunt legate de un anumit nod și pot fi mutate în cluster", "correct": true },
          { "text": "Pentru că bind mount nu mai este suportat de Kubernetes", "correct": false },
          { "text": "Pentru că configurarea prin bind mount este prea rapidă", "correct": false }
        ]
      },
      {
        "question": "Ce este un ConfigMap și la ce se folosește în Kubernetes?",
        "answers": [
          { "text": "Un obiect care stochează perechi cheie-valoare folosite pentru configurarea podurilor", "correct": true },
          { "text": "Un fișier de configurare al nodurilor din cluster", "correct": false },
          { "text": "Un serviciu care monitorizează podurile", "correct": false }
        ]
      },
      {
        "question": "Cum ajută un ConfigMap la separarea configurației de codul aplicației?",
        "answers": [
          { "text": "Configurarea este ținută separat și poate fi modificată fără a reconstrui imaginea", "correct": true },
          { "text": "ConfigMap include automat codul aplicației", "correct": false },
          { "text": "ConfigMap rulează comenzi externe pentru configurare", "correct": false }
        ]
      },
      {
        "question": "Care sunt cele două moduri principale de a folosi un ConfigMap într-un container?",
        "answers": [
          { "text": "Ca variabile de mediu sau ca fișiere montate prin volume", "correct": true },
          { "text": "Ca port forward și log forwarding", "correct": false },
          { "text": "Ca hook-uri de pre-start și post-stop", "correct": false }
        ]
      },
      {
        "question": "Cum putem seta variabile de mediu în container folosind un ConfigMap?",
        "answers": [
          { "text": "Folosind `env` și `valueFrom.configMapKeyRef` în YAML", "correct": true },
          { "text": "Adăugând fișierul ConfigMap direct în container", "correct": false },
          { "text": "Folosing comanda `kubectl set env` fără referințe", "correct": false }
        ]
      },
      {
        "question": "De ce este recomandat să folosim ConfigMap în loc să scriem direct variabilele de mediu în deployment?",
        "answers": [
          { "text": "Pentru că putem modifica valorile fără a edita fișierul deployment", "correct": true },
          { "text": "Pentru că Kubernetes nu suportă variabile de mediu directe", "correct": false },
          { "text": "Pentru că este singura metodă suportată de Helm", "correct": false }
        ]
      },
      {
        "question": "Ce trebuie făcut după modificarea unui ConfigMap pentru ca podul să folosească noile valori?",
        "answers": [
          { "text": "Trebuie restartat podul", "correct": true },
          { "text": "Trebuie șters ConfigMap-ul", "correct": false },
          { "text": "Trebuie reinițiat kubelet", "correct": false }
        ]
      },
      {
        "question": "Ce comandă folosim pentru a inspecta valorile stocate într-un ConfigMap?",
        "answers": [
          { "text": "kubectl describe configmap <nume>", "correct": true },
          { "text": "kubectl get values <nume>", "correct": false },
          { "text": "kubectl logs configmap <nume>", "correct": false }
        ]
      },
      {
        "question": "De ce variabilele de mediu nu sunt suficiente pentru configurații complexe?",
        "answers": [
          { "text": "Pentru că nu putem defini structuri mari sau fișiere întregi", "correct": true },
          { "text": "Pentru că nu pot fi exportate în YAML", "correct": false },
          { "text": "Pentru că variabilele de mediu sunt criptate", "correct": false }
        ]
      },
      {
        "question": "Cum putem încărca un fișier de configurare într-un ConfigMap?",
        "answers": [
          { "text": "Folosind comanda `kubectl create configmap --from-file=<fișier>`", "correct": true },
          { "text": "Folosind comanda `kubectl apply -f <fișier>` direct", "correct": false },
          { "text": "Scriind fișierul în container cu curl", "correct": false }
        ]
      },
      {
        "question": "Cum montăm un fișier dintr-un ConfigMap ca volum într-un container?",
        "answers": [
          { "text": "Declarăm un volum de tip configMap și îl montăm cu volumeMounts", "correct": true },
          { "text": "Îl adăugăm în init container", "correct": false },
          { "text": "Îl montăm prin docker cp", "correct": false }
        ]
      },
      {
        "question": "Ce rol are `volumeMounts` într-un container Kubernetes?",
        "answers": [
          { "text": "Montează un volum la o cale specifică din container", "correct": true },
          { "text": "Descarcă fișiere din cloud în container", "correct": false },
          { "text": "Configurează resursele CPU și memorie", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă serviciile specificate în fișierul de configurare al HAproxy nu există?",
        "answers": [
          { "text": "HAproxy nu va porni", "correct": true },
          { "text": "HAproxy va ignora serviciile lipsă", "correct": false },
          { "text": "HAproxy va crea serviciile automat", "correct": false }
        ]
      },
      {
        "question": "De ce este importantă decuplarea configurației de container în medii distribuite?",
        "answers": [
          { "text": "Pentru că podurile pot rula pe noduri diferite și trebuie configurate dinamic", "correct": true },
          { "text": "Pentru că nodurile distribuie fișierele automat", "correct": false },
          { "text": "Pentru că este necesar pentru update-ul Kubernetes", "correct": false }
        ]
      },
      {
        "question": "Care este principala problemă de securitate atunci când folosim ConfigMap pentru stocarea credențialelor?",
        "answers": [
          { "text": "Oricine are acces la namespace poate vedea datele", "correct": true },
          { "text": "ConfigMap criptează greșit informațiile", "correct": false },
          { "text": "ConfigMap nu poate fi folosit cu volume", "correct": false }
        ]
      },
      {
        "question": "Ce avantaj oferă obiectele de tip Secret față de ConfigMap în Kubernetes?",
        "answers": [
          { "text": "Secretele pot fi obfuscate și criptate, oferind auditare specială", "correct": true },
          { "text": "Secretele pot fi montate doar în namespace-ul default", "correct": false },
          { "text": "Secretele rulează în propriul pod separat", "correct": false }
        ]
      },
      {
        "question": "Care este dezavantajul principal al criptării secretelor în Kubernetes?",
        "answers": [
          { "text": "Necesită o cheie de decriptare introdusă manual de utilizator", "correct": true },
          { "text": "Secretele criptate nu pot fi folosite în Pod-uri", "correct": false },
          { "text": "Criptarea este incompatibilă cu etcd", "correct": false }
        ]
      },
      {
        "question": "Ce rol are tipul asociat unui Secret în Kubernetes?",
        "answers": [
          { "text": "Obligă configurarea anumitor câmpuri și permite interoperabilitate cu alte obiecte", "correct": true },
          { "text": "Îl face incompatibil cu ConfigMap", "correct": false },
          { "text": "Împiedică montarea secretului ca volum", "correct": false }
        ]
      },
      {
        "question": "În ce format sunt stocate valorile dintr-un Secret în Kubernetes?",
        "answers": [
          { "text": "Base64", "correct": true },
          { "text": "YAML pur", "correct": false },
          { "text": "JSON criptat", "correct": false }
        ]
      },
      {
        "question": "Cum expunem valorile dintr-un Secret într-un Pod?",
        "answers": [
          { "text": "Folosim `secretKeyRef`, similar cu `configMapKeyRef`", "correct": true },
          { "text": "Folosim `valueRef` și `secretMount`", "correct": false },
          { "text": "Folosim `envFrom` dintr-un config.yaml", "correct": false }
        ]
      },
      {
        "question": "Ce este un volum persistent în Kubernetes?",
        "answers": [
          { "text": "Un spațiu de stocare asociat cu un pod, independent de ciclul de viață al acestuia", "correct": true },
          { "text": "Un fișier temporar generat la rularea podului", "correct": false },
          { "text": "Un volum atașat doar în timpul creării unui container", "correct": false }
        ]
      },
      {
        "question": "Ce avantaj oferă volumele persistente în Kubernetes?",
        "answers": [
          { "text": "Datele rămân salvate chiar dacă podul este șters", "correct": true },
          { "text": "Permite rularea aplicațiilor fără conexiune la rețea", "correct": false },
          { "text": "Crește viteza de execuție a podurilor", "correct": false }
        ]
      },
      {
        "question": "Ce tip de aplicații beneficiază de volume persistente?",
        "answers": [
          { "text": "Aplicațiile care trebuie să partajeze date între mai multe componente", "correct": true },
          { "text": "Aplicațiile complet stateless", "correct": false },
          { "text": "Aplicațiile care rulează doar în containerul init", "correct": false }
        ]
      },
      {
        "question": "Ce permite mutarea workloadurilor între noduri cu downtime minim?",
        "answers": [
          { "text": "Folosirea volumelor de stocare detașabile", "correct": true },
          { "text": "Dezactivarea autoscaling-ului", "correct": false },
          { "text": "Crearea de poduri fără volume", "correct": false }
        ]
      },
      {
        "question": "Ce este un StorageClass în Kubernetes?",
        "answers": [
          { "text": "Un obiect care definește cum este provisionat un volum", "correct": true },
          { "text": "Un pod special pentru stocare", "correct": false },
          { "text": "O unitate de măsură pentru spațiul disponibil", "correct": false }
        ]
      },
      {
        "question": "Ce rol are storage class-ul default?",
        "answers": [
          { "text": "Este folosit dacă nu se specifică altul la alocarea volumului", "correct": true },
          { "text": "Blochează utilizarea altor clase", "correct": false },
          { "text": "Este utilizat doar pentru poduri stateless", "correct": false }
        ]
      },
      {
        "question": "Ce driver folosește minikube pentru storage class-ul implicit?",
        "answers": [
          { "text": "hostpath", "correct": true },
          { "text": "nfs", "correct": false },
          { "text": "ceph", "correct": false }
        ]
      },
      {
        "question": "Care este obiectul care reprezintă efectiv un spațiu pe un sistem de stocare?",
        "answers": [
          { "text": "PersistentVolume", "correct": true },
          { "text": "StorageClass", "correct": false },
          { "text": "Pod", "correct": false }
        ]
      },
      {
        "question": "Ce specifică atributul `accessModes` dintr-un PV?",
        "answers": [
          { "text": "Modul în care poate fi accesat volumul (de exemplu, ReadWriteOnce)", "correct": true },
          { "text": "Cine poate șterge volumul", "correct": false },
          { "text": "Prioritatea alocării volumului", "correct": false }
        ]
      },
      {
        "question": "Ce indică valoarea `ReadWriteOnce`?",
        "answers": [
          { "text": "Volumul poate fi accesat de un singur nod", "correct": true },
          { "text": "Volumul poate fi accesat de mai multe noduri", "correct": false },
          { "text": "Volumul este doar în citire", "correct": false }
        ]
      },
      {
        "question": "Care este scopul câmpului `capacity` în PV?",
        "answers": [
          { "text": "Indică cât spațiu este disponibil pentru scheduling", "correct": true },
          { "text": "Reprezintă limita strictă a spațiului pe disc", "correct": false },
          { "text": "Definește numărul maxim de poduri ce pot folosi volumul", "correct": false }
        ]
      },
      {
        "question": "Ce este `claimRef` într-un manifest de PV?",
        "answers": [
          { "text": "Referința la PVC-ul care va folosi volumul", "correct": true },
          { "text": "Referința la Podul care va monta volumul", "correct": false },
          { "text": "ID-ul nodului care conține volumul", "correct": false }
        ]
      },
      {
        "question": "Care este funcția atributului `hostPath` într-un PV?",
        "answers": [
          { "text": "Specifică locația de pe disc unde se află volumul", "correct": true },
          { "text": "Definește modul de acces la volum", "correct": false },
          { "text": "Indică endpoint-ul de rețea al volumului", "correct": false }
        ]
      },
      {
        "question": "Ce stare are un volum PV imediat după creare?",
        "answers": [
          { "text": "Available", "correct": true },
          { "text": "Pending", "correct": false },
          { "text": "Bound", "correct": false }
        ]
      },
      {
        "question": "Cum se numește obiectul care cere spațiu de la un PV?",
        "answers": [
          { "text": "PersistentVolumeClaim (PVC)", "correct": true },
          { "text": "PodVolume", "correct": false },
          { "text": "VolumeRequest", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă când un PVC este alocat unui PV?",
        "answers": [
          { "text": "Starea PV devine Bound", "correct": true },
          { "text": "Starea PVC devine Terminated", "correct": false },
          { "text": "Se creează automat un nou StorageClass", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă cu datele din PV dacă PVC-ul este șters?",
        "answers": [
          { "text": "Datele rămân salvate în volum", "correct": true },
          { "text": "Datele sunt șterse automat", "correct": false },
          { "text": "PV-ul este distrus imediat", "correct": false }
        ]
      },
      {
        "question": "Cum se montează un PVC într-un pod?",
        "answers": [
          { "text": "Prin definirea lui în secțiunea `volumes` și `volumeMounts`", "correct": true },
          { "text": "Doar prin includerea PVC-ului în metadata", "correct": false },
          { "text": "Automat la crearea podului", "correct": false }
        ]
      },
      {
        "question": "Unde este specificat calea de montare a unui volum în container?",
        "answers": [
          { "text": "În câmpul `mountPath`", "correct": true },
          { "text": "În câmpul `claimRef`", "correct": false },
          { "text": "În metadata-ul podului", "correct": false }
        ]
      },
      {
        "question": "Ce permite folosirea unui PVC într-un pod?",
        "answers": [
          { "text": "Partajarea volumului între mai multe containere", "correct": true },
          { "text": "Crearea automată de deploymenturi", "correct": false },
          { "text": "Evitarea folosirii unui manifest YAML", "correct": false }
        ]
      },
      {
        "question": "Ce se întâmplă dacă storage class-ul permite provisioning automat?",
        "answers": [
          { "text": "Va fi creat automat un PV conform cerințelor PVC-ului", "correct": true },
          { "text": "Va fi creat automat un nou nod", "correct": false },
          { "text": "Va fi generat un nou deployment", "correct": false }
        ]
      },
      {
        "question": "Ce definește câmpul `storageClassName` din PV sau PVC?",
        "answers": [
          { "text": "Tipul de provisioning folosit pentru volum", "correct": true },
          { "text": "Spațiul maxim disponibil", "correct": false },
          { "text": "Permisiunile utilizatorilor", "correct": false }
        ]
      },
      {
        "question": "Cum poate fi verificată starea unui PV și PVC?",
        "answers": [
          { "text": "Cu comanda `kubectl get pv,pvc`", "correct": true },
          { "text": "Cu comanda `kubectl describe volume`", "correct": false },
          { "text": "Cu comanda `kubectl logs`", "correct": false }
        ]
      },
      {
        "question": "Ce valoare are `RECLAIMPOLICY` în exemplul din minikube?",
        "answers": [
          { "text": "Delete", "correct": true },
          { "text": "Retain", "correct": false },
          { "text": "Recycle", "correct": false }
        ]
      },
      {
        "question": "Ce mod de volum binding este folosit în storage class-urile demo?",
        "answers": [
          { "text": "Immediate", "correct": true },
          { "text": "WaitForFirstConsumer", "correct": false },
          { "text": "OnDemand", "correct": false }
        ]
      }
    ]

    const CC10 = [
      {
        "question": "Ce este OpenShift în raport cu Kubernetes?",
        "answers": [
          { "text": "O distribuție de Kubernetes oferită de Red Hat", "correct": true },
          { "text": "Un sistem de operare pentru containere", "correct": false },
          { "text": "Un motor de căutare pentru clustere", "correct": false }
        ]
      },
      {
        "question": "Cine oferă suport pentru varianta Open Source a OpenShift?",
        "answers": [
          { "text": "Comunitatea", "correct": true },
          { "text": "Microsoft", "correct": false },
          { "text": "Google Cloud", "correct": false }
        ]
      },
      {
        "question": "Ce funcționalitate oferă OpenShift pentru a ușura administrarea unui cluster Kubernetes?",
        "answers": [
          { "text": "Abstractizează complexități precum deploymentul în OpenStack sau integrarea cu OIDC", "correct": true },
          { "text": "Elimină nevoia de noduri worker", "correct": false },
          { "text": "Furnizează direct aplicații web pentru utilizatori", "correct": false }
        ]
      },
      {
        "question": "Ce oferă OpenShift pentru a mări vizibilitatea asupra platformei?",
        "answers": [
          { "text": "Dashboarduri și automatizări", "correct": true },
          { "text": "Backup automat pentru poduri", "correct": false },
          { "text": "Acces root la toate containerele", "correct": false }
        ]
      },
      {
        "question": "Ce sunt operatorii în Kubernetes?",
        "answers": [
          { "text": "Plugin-uri care adaugă obiecte și funcționalități noi în Kubernetes", "correct": true },
          { "text": "Conturi de utilizatori cu roluri speciale", "correct": false },
          { "text": "Sisteme externe de monitorizare", "correct": false }
        ]
      },
      {
        "question": "Un exemplu de funcționalitate oferită de un operator este:",
        "answers": [
          { "text": "Instalarea și folosirea de drivere pentru GPU-uri", "correct": true },
          { "text": "Crearea de volume permanente prin comenzi bash", "correct": false },
          { "text": "Dezactivarea autentificării pentru utilizatori", "correct": false }
        ]
      },
      {
        "question": "Ce beneficiu oferă operatorii Kubernetes administratorilor?",
        "answers": [
          { "text": "Reduc complexitatea de administrare și deployment", "correct": true },
          { "text": "Elimină complet nevoia de configurare YAML", "correct": false },
          { "text": "Dezactivează securitatea rețelei", "correct": false }
        ]
      },
      {
        "question": "Operatorii pot oferi funcționalități accesibile pentru utilizatori în funcție de:",
        "answers": [
          { "text": "Permisiuni", "correct": true },
          { "text": "Versiunea de Kubernetes", "correct": false },
          { "text": "Tipul de container", "correct": false }
        ]
      },
      {
        "question": "OpenShift oferă suport suplimentar pentru clienții Red Hat sub forma:",
        "answers": [
          { "text": "Operatori exclusivi și plugin-uri", "correct": true },
          { "text": "Reduceri la licențe Kubernetes", "correct": false },
          { "text": "Acces gratuit la noduri nelimitate", "correct": false }
        ]
      },
      {
        "question": "Ce exemplu de operator este relevant pentru dezvoltarea de aplicații?",
        "answers": [
          { "text": "Generarea de workspace-uri și IDE-uri automat", "correct": true },
          { "text": "Crearea automată de poduri pentru baze de date", "correct": false },
          { "text": "Reducerea dimensiunii imaginilor container", "correct": false }
        ]
      },
      {
        "question": "Ce sunt Batch Jobs în Kubernetes?",
        "answers": [
          { "text": "O formă de a programa munca sub formă de joburi distincte", "correct": true },
          { "text": "Servicii web care rulează continuu", "correct": false },
          { "text": "Instrumente de rețea pentru comunicație între poduri", "correct": false }
        ]
      },
      {
        "question": "De ce nu este necesar un API pentru orice formă de procesare?",
        "answers": [
          { "text": "Pentru că unele sarcini pot fi executate ca joburi batch, nu continuu", "correct": true },
          { "text": "Pentru că Kubernetes oferă API-uri implicite pentru orice", "correct": false },
          { "text": "Pentru că joburile batch nu consumă resurse", "correct": false }
        ]
      },
      {
        "question": "Ce lipsuri au batch joburile Kubernetes comparativ cu sistemele dedicate de batch queue?",
        "answers": [
          { "text": "Nu au limite implicite de timp și necesită implementări adiționale", "correct": true },
          { "text": "Nu pot rula comenzi în containere", "correct": false },
          { "text": "Nu pot fi lansate din YAML", "correct": false }
        ]
      },
      {
        "question": "Ce instrument este recomandat pentru comportamente mai complexe cum ar fi înlănțuirea joburilor sau triggere?",
        "answers": [
          { "text": "Argo Workflows", "correct": true },
          { "text": "Helm Charts", "correct": false },
          { "text": "KubeProxy", "correct": false }
        ]
      },
      {
        "question": "Ce trebuie specificat într-un job Kubernetes?",
        "answers": [
          { "text": "Podul în care rulează și comanda care va fi rulată", "correct": true },
          { "text": "Numărul de noduri și politica de scalare", "correct": false },
          { "text": "Strategia de autoscaling și tipul de serviciu", "correct": false }
        ]
      },
      {
        "question": "Ce sunt Cron Jobs în Kubernetes?",
        "answers": [
          { "text": "Joburi programate care rulează repetitiv la intervale definite", "correct": true },
          { "text": "Servicii expuse permanent în rețea", "correct": false },
          { "text": "Controllere care gestionează deployment-uri", "correct": false }
        ]
      },
      {
        "question": "Ce generează un Cron Job la momentul programat?",
        "answers": [
          { "text": "Obiecte de tip Job", "correct": true },
          { "text": "Noi poduri de sistem", "correct": false },
          { "text": "Alarme și notificări", "correct": false }
        ]
      },
      {
        "question": "Ce format este folosit pentru a specifica programul de execuție al unui Cron Job?",
        "answers": [
          { "text": "Sintaxa cron-urilor UNIX", "correct": true },
          { "text": "Format JSON cu timestampuri", "correct": false },
          { "text": "Format ISO-8601", "correct": false }
        ]
      },
      {
        "question": "Care este un exemplu de utilizare comună a Cron Jobs?",
        "answers": [
          { "text": "Backup al sistemelor pentru disaster recovery", "correct": true },
          { "text": "Routing de trafic între servicii", "correct": false },
          { "text": "Monitorizarea automată a containerelor", "correct": false }
        ]
      },
      {
        "question": "Ce conține un jobTemplate într-un Cron Job?",
        "answers": [
          { "text": "Specificația unui job care va fi rulat conform programării", "correct": true },
          { "text": "Un șablon pentru crearea de servicii", "correct": false },
          { "text": "Configurația rețelei podurilor", "correct": false }
        ]
      },
      {
        "question": "De ce este important să folosim eficient GPU-urile în cadrul unui cluster?",
        "answers": [
          { "text": "Pentru a evita resurse neutilizate sau cicluri moarte", "correct": true },
          { "text": "Pentru a crește temperatura GPU-ului", "correct": false },
          { "text": "Pentru a consuma mai multă memorie RAM", "correct": false }
        ]
      },
      {
        "question": "De ce este utilă împărțirea unui GPU între mai multe workloaduri?",
        "answers": [
          { "text": "Pentru a maximiza utilizarea resurselor disponibile", "correct": true },
          { "text": "Pentru a reduce viteza de execuție", "correct": false },
          { "text": "Pentru a limita utilizarea procesorului", "correct": false }
        ]
      },
      {
        "question": "Care este vendorul cel mai popular pentru GPU sharing în Kubernetes?",
        "answers": [
          { "text": "Nvidia", "correct": true },
          { "text": "AMD", "correct": false },
          { "text": "Intel", "correct": false }
        ]
      },
      {
        "question": "Ce înseamnă MIG în contextul GPU sharing?",
        "answers": [
          { "text": "Multi Instance GPUs", "correct": true },
          { "text": "Multiple Interconnected GPUs", "correct": false },
          { "text": "Minimal Integrated Graphics", "correct": false }
        ]
      },
      {
        "question": "Ce oferă MIG în materie de izolare între workloaduri?",
        "answers": [
          { "text": "Izolare completă", "correct": true },
          { "text": "Acces partajat în regim colaborativ", "correct": false },
          { "text": "Nicio izolare", "correct": false }
        ]
      },
      {
        "question": "Care este un dezavantaj al utilizării MIG?",
        "answers": [
          { "text": "Necesită intervenția administratorului pentru configurare", "correct": true },
          { "text": "Nu poate fi folosit în Kubernetes", "correct": false },
          { "text": "Funcționează doar cu procesoare AMD", "correct": false }
        ]
      },
      {
        "question": "Ce este MPS în contextul GPU sharing?",
        "answers": [
          { "text": "Multi-Process Service", "correct": true },
          { "text": "Modul Paralel de Stocare", "correct": false },
          { "text": "Middleware pentru Poduri Securizate", "correct": false }
        ]
      },
      {
        "question": "Care este riscul major asociat cu MPS?",
        "answers": [
          { "text": "Vulnerabilități de securitate sau information leaks", "correct": true },
          { "text": "Folosirea excesivă a energiei", "correct": false },
          { "text": "Incompatibilitatea cu workloadurile containerizate", "correct": false }
        ]
      },
      {
        "question": "Cum funcționează modelul de lucru în MPS?",
        "answers": [
          { "text": "Procesele rulează în paralel și împart resursele GPU", "correct": true },
          { "text": "Procesele se exclud reciproc", "correct": false },
          { "text": "Un singur job rulează pe GPU la un moment dat", "correct": false }
        ]
      },
      {
        "question": "Ce reprezintă 'Time Slices' în contextul GPU sharing?",
        "answers": [
          { "text": "Felierea timpului de execuție pe GPU între procese", "correct": true },
          { "text": "Divizarea memoriei RAM", "correct": false },
          { "text": "Alocarea prioritară a traficului de rețea", "correct": false }
        ]
      },
      {
        "question": "Care este dezavantajul principal al folosirii Time Slices?",
        "answers": [
          { "text": "Overhead mare din cauza schimbărilor de context", "correct": true },
          { "text": "Izolare completă între workloaduri", "correct": false },
          { "text": "Lipsa compatibilității cu GPU-urile Nvidia", "correct": false }
        ]
      },
      {
        "question": "Cum pot fi prioritizate joburile în Kubernetes atunci când se folosesc Time Slices?",
        "answers": [
          { "text": "Prin specificarea unui nivel de prioritate care influențează durata slice-ului", "correct": true },
          { "text": "Prin utilizarea de anotări pe poduri", "correct": false },
          { "text": "Prin limitarea memoriei CPU", "correct": false }
        ]
      },
      {
        "question": "Ce tip de workload ar trebui să primească un slice de timp mai mare?",
        "answers": [
          { "text": "Un workload grafic cu output vizibil pentru utilizator", "correct": true },
          { "text": "Un proces de mentenanță rar folosit", "correct": false },
          { "text": "Un job de backup în fundal", "correct": false }
        ]
      },
      {
        "question": "Ce avantaj aduce alocarea exclusivă a GPU-ului prin Time Slices?",
        "answers": [
          { "text": "Izolare între procese în timpul execuției", "correct": true },
          { "text": "Execuție paralelă nelimitată", "correct": false },
          { "text": "Partajare eficientă de memorie RAM", "correct": false }
        ]
      }
    ];



    let quizzes = [];
    let correctAnswersCount = 0; // Track the number of correct answers

    async function loadQuiz() {
      const select = document.getElementById('courseSelect').value;

      if (select === 'CC-04') {
        quizzes = CC04;
      }
      if (select === 'CC-05') {
        quizzes = CC05;
      }
      if (select === 'CC-07') {
        quizzes = CC07;
      }
      if (select === 'CC-08') {
        quizzes = CC08;
      }

      if (select === 'CC-09') {
        quizzes = CC09;
      }

      if (select === 'CC-10') {
        quizzes = CC10;
      }

      // Check if random order for questions is selected
      const randomOrder = document.getElementById('randomToggle').checked;

      if (randomOrder) {
        quizzes.sort(() => 0.5 - Math.random());
      }

      const quizContainer = document.getElementById('quiz-container');
      quizContainer.innerHTML = '';

      // Hide course selection after loading
      document.getElementById('courseSelection').style.display = 'none';

      quizzes.forEach((quiz, index) => {
        const quizSection = document.createElement('div');
        quizSection.id = `quiz-${index + 1}`;
        quizSection.classList.add('quiz-section');
        if (index === 0) quizSection.classList.add('active');

        // Check if random order for answers is selected
        const answerRandomOrder = document.getElementById('answerRandomToggle').checked;

        const answers = answerRandomOrder ? quiz.answers.sort(() => 0.5 - Math.random()) : quiz.answers;

        quizSection.innerHTML = `
          <div class="question-info">Întrebarea ${index + 1} din ${quizzes.length}</div>
          <div class="question">${quiz.question}</div>
          ${answers.map((answer, i) => `
            <div class="answer">
              <input type="radio" name="q${index + 1}" id="q${index + 1}-answer${i}" value="${answer.correct ? 1 : 0}" /> 
              <span onclick="document.getElementById('q${index + 1}-answer${i}').click();">${answer.text}</span>
            </div>`).join('')}
          <div id="feedback-${index + 1}" class="feedback"></div>
          <div id="correct-answer-${index + 1}" class="feedback" style="color: blue;"></div>
          <button class="next-btn" onclick="checkAnswer(${index + 1}, 1)">Submit</button>
        `;

        quizContainer.appendChild(quizSection);
      });
    }

    function checkAnswer(quizNumber, correctAnswer) {
      const selectedOption = document.querySelector(`input[name="q${quizNumber}"]:checked`);
      const feedback = document.getElementById(`feedback-${quizNumber}`);
      const correctAnswerDisplay = document.getElementById(`correct-answer-${quizNumber}`);
      const quiz = quizzes[quizNumber - 1];

      if (selectedOption) {
        if (parseInt(selectedOption.value) === correctAnswer) {
          feedback.textContent = "Răspuns corect!";
          feedback.style.color = "green";
          correctAnswersCount++; // Increment correct answers count
        } else {
          feedback.textContent = "Răspuns greșit!";
          feedback.style.color = "red";
          correctAnswerDisplay.textContent = `Răspunsul corect este: ${quiz.answers.find(a => a.correct).text}`;
        }

        const nextButton = document.querySelector(`#quiz-${quizNumber} .next-btn`);
        nextButton.textContent = "Următoarea Întrebare";
        nextButton.onclick = function () {
          goToNextQuestion(quizNumber + 1);
        };
      } else {
        feedback.textContent = "Selectați un răspuns!";
        feedback.style.color = "orange";
      }
    }

    function goToNextQuestion(nextQuizNumber) {
      document.querySelector(`#quiz-${nextQuizNumber - 1}`).classList.remove("active");
      const nextQuiz = document.getElementById(`quiz-${nextQuizNumber}`);
      if (nextQuiz) {
        nextQuiz.classList.add("active");
        document.getElementById(`feedback-${nextQuizNumber - 1}`).textContent = '';
        document.getElementById(`correct-answer-${nextQuizNumber - 1}`).textContent = '';
      } else {
        // Quiz completed, show results
        alert(`Quiz complet! Felicitări! Ați răspuns corect la ${correctAnswersCount} din ${quizzes.length} întrebări.`);
      }
    }
  </script>
</body>

</html>